Load function ${"ja":"実数表示", "natja":"実数表示", "en":"printDouble", "naten":"printDouble"}$ from "log"of "console"that takes x as double . 
Load function ${"ja":"行列表示", "natja":"行列表示", "en":"printMatrix", "naten":"printMatrix"}$ from "logMatrix"of "console"that takes element 4 in element 4 in offset as double . 
Load function ${"ja":"アドレス表示", "natja":"アドレス表示", "en":"printAddress", "naten":"printAddress"}$ from "log"of "console"that takes x as pointer of void . 
Load function ${"ja":"_文字列表示", "natja":"_文字列表示", "en":"_printString", "naten":"_printString"}$ from "logstring"of "console"that takes x as pointer of char , 長さ as int . 
Load function ${"ja":"時間計測", "natja":"時間計測", "en":"getTime", "naten":"getTime"}$ from "now"of "performance"that returns 時間 as double . 
Load function ${"ja":"glClearDepth", "natja":"glClearDepth", "en":"glClearDepth", "naten":"glClearDepth"}$ from "clearDepth"of "webgl"that takes i as short . 
Load function ${"ja":"glDepthFunc", "natja":"glDepthFunc", "en":"glDepthFunc", "naten":"glDepthFunc"}$ from "depthFunc"of "webgl"that takes i as short . 
Load function ${"ja":"glEnable", "natja":"glEnable", "en":"glEnable", "naten":"glEnable"}$ from "enable"of "webgl"that takes i as short . 
Load function ${"ja":"glDisable", "natja":"glDisable", "en":"glDisable", "naten":"glDisable"}$ from "disable"of "webgl"that takes i as short . 
Load function ${"ja":"glCreateProgram", "natja":"glCreateProgram", "en":"glCreateProgram", "naten":"glCreateProgram"}$ from "createProgram"of "webgl"that returns prog as short . 
Load function ${"ja":"glCreateBuffer", "natja":"glCreateBuffer", "en":"glCreateBuffer", "naten":"glCreateBuffer"}$ from "createBuffer"of "webgl"that returns buffer as short . 
Load function ${"ja":"glBindBuffer", "natja":"glBindBuffer", "en":"glBindBuffer", "naten":"glBindBuffer"}$ from "bindBuffer"of "webgl"that takes i as short , j as short . 
Load function ${"ja":"glBufferData", "natja":"glBufferData", "en":"glBufferData", "naten":"glBufferData"}$ from "bufferData"of "webgl"that takes i as short , offset as pointer of double , size as short , j as short . 
Load function ${"ja":"glElementBufferData", "natja":"glElementBufferData", "en":"glElementBufferData", "naten":"glElementBufferData"}$ from "elementBufferData"of "webgl"that takes i as short , offset as pointer of short , size as short , j as short . 
Load function ${"ja":"glUseProgram", "natja":"glUseProgram", "en":"glUseProgram", "naten":"glUseProgram"}$ from "useProgram"of "webgl"that takes i as short . 
Load function ${"ja":"glGetAttribLocation", "natja":"glGetAttribLocation", "en":"glGetAttribLocation", "naten":"glGetAttribLocation"}$ from "getAttribLocation"of "webgl"that takes i as short , offset as pointer of char , size as short and returns loc as short . 
Load function ${"ja":"glVertexAttribPointer", "natja":"glVertexAttribPointer", "en":"glVertexAttribPointer", "naten":"glVertexAttribPointer"}$ from "vertexAttribPointer"of "webgl"that takes index as short , size as short , ty as short , normalized as short , stride as short , offset as short . 
Load function ${"ja":"glEnableVertexAttribArray", "natja":"glEnableVertexAttribArray", "en":"glEnableVertexAttribArray", "naten":"glEnableVertexAttribArray"}$ from "enableVertexAttribArray"of "webgl"that takes index as short . 
Load function ${"ja":"glDrawArrays", "natja":"glDrawArrays", "en":"glDrawArrays", "naten":"glDrawArrays"}$ from "drawArrays"of "webgl"that takes i as short , first as short , count as short . 
Load function ${"ja":"_glGetUniformLocation", "natja":"_glGetUniformLocation", "en":"_glGetUniformLocation", "naten":"_glGetUniformLocation"}$ from "getUniformLocation"of "webgl"that takes i as short , offset as pointer of char , size as short and returns loc as short . 
Load function ${"ja":"glUniformMatrix2fv", "natja":"glUniformMatrix2fv", "en":"glUniformMatrix2fv", "naten":"glUniformMatrix2fv"}$ from "uniformMatrix2fv"of "webgl"that takes loc as short , trans as short , offset as pointer of double . 
Load function ${"ja":"glUniformMatrix3fv", "natja":"glUniformMatrix3fv", "en":"glUniformMatrix3fv", "naten":"glUniformMatrix3fv"}$ from "uniformMatrix3fv"of "webgl"that takes loc as short , trans as short , offset as pointer of double . 
Load function ${"ja":"glUniformMatrix4fv", "natja":"glUniformMatrix4fv", "en":"glUniformMatrix4fv", "naten":"glUniformMatrix4fv"}$ from "uniformMatrix4fv"of "webgl"that takes loc as short , trans as short , element 16 in offset as double . 
Load function ${"ja":"glUniform1f", "natja":"glUniform1f", "en":"glUniform1f", "naten":"glUniform1f"}$ from "uniform1f"of "webgl"that takes loc as short , v0 as double . 
Load function ${"ja":"glUniform1fv", "natja":"glUniform1fv", "en":"glUniform1fv", "naten":"glUniform1fv"}$ from "uniform1fv"of "webgl"that takes loc as short , v0 as double . 
Load function ${"ja":"glUniform1i", "natja":"glUniform1i", "en":"glUniform1i", "naten":"glUniform1i"}$ from "uniform1i"of "webgl"that takes loc as short , v0 as short . 
Load function ${"ja":"glUniform1iv", "natja":"glUniform1iv", "en":"glUniform1iv", "naten":"glUniform1iv"}$ from "uniform1iv"of "webgl"that takes loc as short , v0 as short . 
Load function ${"ja":"glUniform2f", "natja":"glUniform2f", "en":"glUniform2f", "naten":"glUniform2f"}$ from "uniform2f"of "webgl"that takes loc as short , v0 as double , v1 as double . 
Load function ${"ja":"glUniform2fv", "natja":"glUniform2fv", "en":"glUniform2fv", "naten":"glUniform2fv"}$ from "uniform2fv"of "webgl"that takes loc as short , v0 as double , v1 as double . 
Load function ${"ja":"glUniform2i", "natja":"glUniform2i", "en":"glUniform2i", "naten":"glUniform2i"}$ from "uniform2i"of "webgl"that takes loc as short , v0 as short , v1 as short . 
Load function ${"ja":"glUniform2iv", "natja":"glUniform2iv", "en":"glUniform2iv", "naten":"glUniform2iv"}$ from "uniform2iv"of "webgl"that takes loc as short , v0 as short , v1 as short . 
Load function ${"ja":"glUniform3f", "natja":"glUniform3f", "en":"glUniform3f", "naten":"glUniform3f"}$ from "uniform3f"of "webgl"that takes loc as short , v0 as double , v1 as double , v2 as double . 
Load function ${"ja":"glUniform3fv", "natja":"glUniform3fv", "en":"glUniform3fv", "naten":"glUniform3fv"}$ from "uniform3fv"of "webgl"that takes loc as short , v0 as double , v1 as double , v2 as double . 
Load function ${"ja":"glUniform3i", "natja":"glUniform3i", "en":"glUniform3i", "naten":"glUniform3i"}$ from "uniform3i"of "webgl"that takes loc as short , v0 as short , v1 as short , v2 as short . 
Load function ${"ja":"glUniform3iv", "natja":"glUniform3iv", "en":"glUniform3iv", "naten":"glUniform3iv"}$ from "uniform3iv"of "webgl"that takes loc as short , v0 as short , v1 as short , v2 as short . 
Load function ${"ja":"glUniform4f", "natja":"glUniform4f", "en":"glUniform4f", "naten":"glUniform4f"}$ from "uniform4f"of "webgl"that takes loc as short , v0 as double , v1 as double , v2 as double , v3 as double . 
Load function ${"ja":"glUniform4fv", "natja":"glUniform4fv", "en":"glUniform4fv", "naten":"glUniform4fv"}$ from "uniform4fv"of "webgl"that takes loc as short , v0 as double , v1 as double , v2 as double , v3 as double . 
Load function ${"ja":"glUniform4i", "natja":"glUniform4i", "en":"glUniform4i", "naten":"glUniform4i"}$ from "uniform4i"of "webgl"that takes loc as short , v0 as short , v1 as short , v2 as short , v3 as short . 
Load function ${"ja":"glUniform4iv", "natja":"glUniform4iv", "en":"glUniform4iv", "naten":"glUniform4iv"}$ from "uniform4iv"of "webgl"that takes loc as short , v0 as short , v1 as short , v2 as short , v3 as short . 
Load function ${"ja":"glClearColor", "natja":"glClearColor", "en":"glClearColor", "naten":"glClearColor"}$ from "clearColor"of "webgl"that takes r as double , g as double , b as double , a as double . 
Load function ${"ja":"glClear", "natja":"glClear", "en":"glClear", "naten":"glClear"}$ from "clear"of "webgl"that takes color as short . 
Load function ${"ja":"glDrawElements", "natja":"glDrawElements", "en":"glDrawElements", "naten":"glDrawElements"}$ from "drawElements"of "webgl"that takes i as short , count as short , ty as short , offset as short . 
Load function ${"ja":"glBlendFunc", "natja":"glBlendFunc", "en":"glBlendFunc", "naten":"glBlendFunc"}$ from "blendFunc"of "webgl"that takes i as short , j as short . 
Load function ${"ja":"キーチェック", "natja":"キーチェック", "en":"checkKeyPress", "naten":"checkKeyPress"}$ from "checkKeyPress"of "js"that takes keyCode as short and returns pressed as int . 
Load function ${"ja":"マウスチェック", "natja":"マウスチェック", "en":"checkMousePress", "naten":"checkMousePress"}$ from "checkMousePress"of "js"that returns pressed as int . 
Load function ${"ja":"マウス相対座標X", "natja":"マウス相対座標X", "en":"checkRelativeMouseX", "naten":"checkRelativeMouseX"}$ from "checkRelativeMouseX"of "js"that returns x as double . 
Load function ${"ja":"マウス相対座標Y", "natja":"マウス相対座標Y", "en":"checkRelativeMouseY", "naten":"checkRelativeMouseY"}$ from "checkRelativeMouseY"of "js"that returns x as double . 
Load function ${"ja":"マウス絶対座標X", "natja":"マウス絶対座標X", "en":"checkAbsoluteMouseX", "naten":"checkAbsoluteMouseX"}$ from "checkAbsoluteMouseX"of "js"that returns x as double . 
Load function ${"ja":"マウス絶対座標Y", "natja":"マウス絶対座標Y", "en":"checkAbsoluteMouseY", "naten":"checkAbsoluteMouseY"}$ from "checkAbsoluteMouseY"of "js"that returns x as double . 
Load function ${"ja":"ランダム数生成", "natja":"ランダム数生成", "en":"rand", "naten":"rand"}$ from "rand"of "js"that returns x as double . 
Load function ${"ja":"メモリ確保", "natja":"メモリ確保", "en":"allocMemory", "naten":"allocMemory"}$ from "alloc"of "js"that takes size as short and returns p as pointer of void . 
Load function ${"ja":"テクスチャロード", "natja":"テクスチャロード", "en":"_loadTexture", "naten":"_loadTexture"}$ from "loadTexture"of "webgl"that takes offset as pointer of char , length as short and returns a as short . 
Load function ${"ja":"glActiveTexture", "natja":"glActiveTexture", "en":"glActiveTexture", "naten":"glActiveTexture"}$ from "activeTexture"of "webgl"that takes i as short . 
Load function ${"ja":"glBindTexture", "natja":"glBindTexture", "en":"glBindTexture", "naten":"glBindTexture"}$ from "bindTexture"of "webgl"that takes i as short , j as short . 
Load function ${"ja":"マウスキャプチャ", "natja":"マウスキャプチャ", "en":"captureMouse", "naten":"captureMouse"}$ from "lockPointer"of "js". 
Declare function ${"ja":"sin", "natja":"sin", "en":"sin", "naten":"sin"}$ that takes input as double and returns 結果 as double with code starting here
	Initialize variable PI as double with 3.14159265358979312 . 
	Initialize variable temp as int with input  / ( 2.0  * PI ) . 
	Initialize variable rad as double with input  - ( 2.0  * PI  * temp ) . 
	Initialize variable plusminus as double with 1.0 . 
	If rad  < 0.0 then execute code starting here
		Assign rad  + ( 2.0  * PI ) to rad . 
	ending here 
	If rad  > PI then execute code starting here
		Assign 0  - 1.0 to plusminus . 
		If rad  > 1.5  * PI then execute code starting here
			Assign ( 2.0  * PI )  - rad to rad . 
		ending here Otherwise execute code starting here
			Assign rad  - PI to rad . 
		ending here 
	ending here Otherwise execute code starting here
		If rad  > 0.5  * PI then execute code starting here
			Assign PI  - rad to rad . 
		ending here 
	ending here 
	If rad  > 0.25  * PI then execute code starting here
		Assign ( 0.5  * PI )  - rad to rad . 
		Initialize variable doubleRad as double with rad  * rad . 
		Assign 1.0  - ( doubleRad )  / 2.0  + ( doubleRad  * doubleRad )  / 24.0  - ( doubleRad  * doubleRad  * doubleRad )  / 720.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 40320.0  - ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 3628800.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 479001600.0 to 結果 . 
		Assign 結果  * plusminus to 結果 . 
	ending here Otherwise execute code starting here
		Initialize variable doubleRad as double with rad  * rad . 
		Assign rad  - ( rad  * doubleRad )  / 6.0  + ( rad  * doubleRad  * doubleRad )  / 120.0  - ( rad  * doubleRad  * doubleRad  * doubleRad )  / 5040.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 362880.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 39916800.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 6227020800.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 1307674368000.0 to 結果 . 
		Assign 結果  * plusminus to 結果 . 
	ending here 
ending here 
Declare function ${"ja":"cos", "natja":"cos", "en":"cos", "naten":"cos"}$ that takes input as double and returns 結果 as double with code starting here
	Initialize variable PI as double with 3.14159265358979312 . 
	Initialize variable temp as int with input  / ( 2  * PI ) . 
	Initialize variable rad as double with input  - ( 2  * PI  * temp ) . 
	Initialize variable plusminus as double with 1.0 . 
	If rad  < 0.0 then execute code starting here
		Assign rad  + ( 2.0  * PI ) to rad . 
	ending here 
	If rad  > PI then execute code starting here
		If rad  > 1.5  * PI then execute code starting here
			Assign ( 2.0  * PI )  - rad to rad . 
		ending here Otherwise execute code starting here
			Assign 0  - 1.0 to plusminus . 
			Assign rad  - PI to rad . 
		ending here 
	ending here Otherwise execute code starting here
		If rad  > 0.5  * PI then execute code starting here
			Assign 0  - 1.0 to plusminus . 
			Assign PI  - rad to rad . 
		ending here 
	ending here 
	If rad  < 0.25  * PI then execute code starting here
		Initialize variable doubleRad as double with rad  * rad . 
		Assign 1.0  - ( doubleRad )  / 2.0  + ( doubleRad  * doubleRad )  / 24.0  - ( doubleRad  * doubleRad  * doubleRad )  / 720.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 40320.0  - ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 3628800.0  + ( doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 479001600.0 to 結果 . 
		Assign 結果  * plusminus to 結果 . 
	ending here Otherwise execute code starting here
		Assign ( 0.5  * PI )  - rad to rad . 
		Initialize variable doubleRad as double with rad  * rad . 
		Assign rad  - ( rad  * doubleRad )  / 6.0  + ( rad  * doubleRad  * doubleRad )  / 120.0  - ( rad  * doubleRad  * doubleRad  * doubleRad )  / 5040.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 362880.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 39916800.0  + ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 6227020800.0  - ( rad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad  * doubleRad )  / 1307674368000.0 to 結果 . 
		Assign 結果  * plusminus to 結果 . 
	ending here 
ending here 
Declare function ${"ja":"tan", "natja":"tan", "en":"tan", "naten":"tan"}$ that takes rad as double and returns 結果 as double with code starting here
	Initialize variable PI as double with 3.14159265358979312 . 
	Initialize variable sqRad as double with rad  * rad . 
	Assign sin ( rad )  / cos ( rad ) to 結果 . 
ending here 
Declare template that takes T . Declare function ${"ja":"abs", "natja":"abs", "en":"abs", "naten":"abs"}$ that takes a as T and returns b as T with code starting here
	If a  >= 0 then execute code starting here
		Assign a to b . 
	ending here Otherwise execute code starting here
		Assign 0  - a to b . 
	ending here 
ending here 
Declare function ${"ja":"ラジアンへ", "natja":"ラジアンへ", "en":"toRad", "naten":"toRad"}$ that takes deg as double and returns rad as double with code starting here
	Initialize variable PI as double with 3.14159265358979312 . 
	Assign ( deg  / 180 )  * PI to rad . 
ending here 
Declare function ${"ja":"平方根", "natja":"平方根", "en":"root", "naten":"root"}$ that takes x as double and returns y as double with code starting here
	Assign 5 to y . 
	( Initialize variable i as int with 0 . ) from ( i  is 20 ) to ( Assign i  + 1 to i . ) starting here
		Assign 0.5  * ( y  + ( x  / y ) ) to y . 
	ending here 
ending here 
Declare template that takes T . Declare class ${"ja":"配列", "natja":"配列", "en":"Array", "naten":"Array"}$ with members starting here
public : 	Declare variable content as pointer of T . 
	Declare variable size as int . 
	Declare function Array with code starting here
		Assign 0 to size . 
		Assign 2 to allocated . 
		Assign allocMemory ( sizeof ( variable at content )  * allocated ) to content . 
	ending here 
	Declare function ${"ja":"取得", "natja":"取得", "en":"get", "naten":"get"}$ that takes index as int and returns result as T with code starting here
		Return value element index in content . 
	ending here 
	Declare function ${"ja":"追加", "natja":"追加", "en":"push", "naten":"push"}$ that takes new as T with code starting here
		If size  is allocated then execute code starting here
			Assign allocated  * 2 to allocated . 
			Initialize variable temp as pointer of T with content . 
			Assign allocMemory ( sizeof ( variable at content )  * allocated ) to content . 
			( Initialize variable i as int with 0 . ) from ( i  is allocated ) to ( Assign i  + 1 to i . ) starting here
				Assign element i in temp to element i in content . 
			ending here 
		ending here 
		Assign new to element size in content . 
		Assign size  + 1 to size . 
	ending here 
	Declare function ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ that returns a as int with code starting here
		Assign size to a . 
	ending here 
	Declare function ${"ja":"ポップ", "natja":"ポップ", "en":"pop", "naten":"pop"}$ with code starting here
		Assign size  - 1 to size . 
	ending here 
private : 	Declare variable allocated as int . 
ending here 
Declare class ${"ja":"文字列", "natja":"文字列", "en":"string", "naten":"string"}$ with members starting here
public : 	Declare variable content as pointer of char . 
	Declare variable length as int . 
	Declare function string that takes offset as pointer of char , l as int with code starting here
		Assign offset to content . 
		Assign l to length . 
	ending here 
	function : operator = ( offset as pointer of char , l as int ) => ( ) starting here
		Assign offset to content . 
		Assign l to length . 
	ending here 
ending here 
Declare function ${"ja":"文字列表示", "natja":"文字列表示", "en":"printString", "naten":"printString"}$ that takes a as string with code starting here
	Call _printString with value content of a , length of a . 
ending here 
Declare function ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ that takes x as double with code starting here
	Call printDouble with value x . 
ending here 
Declare function ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ that takes n as int with code starting here
	Call printDouble with value n . 
ending here 
Declare function ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ that takes n as short with code starting here
	Call printDouble with value n . 
ending here 
Declare function ${"ja":"表示", "natja":"表示", "en":"print", "naten":"print"}$ that takes a as string with code starting here
	Call printString with value a . 
ending here 
Declare function ${"ja":"glGetUniformLocation", "natja":"glGetUniformLocation", "en":"glGetUniformLocation", "naten":"glGetUniformLocation"}$ that takes i as short , a as string and returns loc as short with code starting here
	Assign _glGetUniformLocation ( i , content of a , length of a ) to loc . 
ending here 
Declare class ${"ja":"ベクトル3D", "natja":"ベクトル3D", "en":"Vector3D", "naten":"Vector3D"}$ with members starting here
public : 	Declare variable x as double . 
	Declare variable y as double . 
	Declare variable z as double . 
	Declare function Vector3D that takes a as double , b as double , c as double with code starting here
		Assign a to x . 
		Assign b to y . 
		Assign c to z . 
	ending here 
	Declare function ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ that returns l as double with code starting here
		Assign root ( x  * x  + y  * y  + z  * z ) to l . 
	ending here 
	Declare function ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$ with code starting here
		Initialize variable l as double with root ( ( x  * x )  + ( y  * y )  + ( z  * z ) ) . 
		Assign x  / l to x . 
		Assign y  / l to y . 
		Assign z  / l to z . 
	ending here 
	function : operator  + ( a as Vector3D ) => ( b as Vector3D ) starting here
		Assign x of a  + x to x of b . 
		Assign y of a  + y to y of b . 
		Assign z of a  + z to z of b . 
	ending here 
ending here 
Declare function ${"ja":"ベクトル3Dの和", "natja":"ベクトル3Dの和", "en":"addVector3D", "naten":"addVector3D"}$ that takes a as Vector3D , b as Vector3D and returns result as Vector3D with code starting here
	Assign x of a  + x of b to x of result . 
	Assign y of a  + y of b to y of result . 
	Assign z of a  + z of b to z of result . 
ending here 
Declare function ${"ja":"ベクトル3Dの差", "natja":"ベクトル3Dの差", "en":"subVector3D", "naten":"subVector3D"}$ that takes a as Vector3D , b as Vector3D and returns result as Vector3D with code starting here
	Assign x of a  - x of b to x of result . 
	Assign y of a  - y of b to y of result . 
	Assign z of a  - z of b to z of result . 
ending here 
Declare function ${"ja":"ベクトル3Dの内積", "natja":"ベクトル3Dの内積", "en":"dotVector3D", "naten":"dotVector3D"}$ that takes a as Vector3D , b as Vector3D and returns x as double with code starting here
	Assign ( x of a  * x of b )  + ( y of a  * y of b )  + ( z of a  * z of b ) to x . 
ending here 
Declare function ${"ja":"ベクトル3Dの外積", "natja":"ベクトル3Dの外積", "en":"crossVector3D", "naten":"crossVector3D"}$ that takes a as Vector3D , b as Vector3D and returns result as Vector3D with code starting here
	Assign ( y of a  * z of b )  - ( z of a  * y of b ) to x of result . 
	Assign ( z of a  * x of b )  - ( x of a  * z of b ) to y of result . 
	Assign ( x of a  * y of b )  - ( y of a  * x of b ) to z of result . 
ending here 
Declare function ${"ja":"ベクトル3D拡大", "natja":"ベクトル3D拡大", "en":"extendVector3D", "naten":"extendVector3D"}$ that takes a as Vector3D , x as double and returns result as Vector3D with code starting here
	Assign x of a  * x to x of result . 
	Assign y of a  * x to y of result . 
	Assign z of a  * x to z of result . 
ending here 
Declare function ${"ja":"ベクトル3D縮小", "natja":"ベクトル3D縮小", "en":"divVector3D", "naten":"divVector3D"}$ that takes a as Vector3D , x as double and returns result as Vector3D with code starting here
	If x  is 0.0 then execute code starting here
		Call print with value 10000000 . 
	ending here 
	Assign x of a  / x to x of result . 
	Assign y of a  / x to y of result . 
	Assign z of a  / x to z of result . 
ending here 
Declare class ${"ja":"行列4x4", "natja":"行列4x4", "en":"Matrix4x4", "naten":"Matrix4x4"}$ with members starting here
public : 	Declare variable element 16 in matrix as double . 
	Declare function Matrix4x4 with code starting here
		Assign [ 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] to matrix . 
	ending here 
	Declare function ${"ja":"単位化", "natja":"単位化", "en":"identity", "naten":"identity"}$ with code starting here
		Assign [ 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] to matrix . 
	ending here 
	Declare function ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ that takes offset as Vector3D with code starting here
		Initialize variable mat12 as double with element 12 in matrix . 
		Initialize variable mat13 as double with element 13 in matrix . 
		Initialize variable mat14 as double with element 14 in matrix . 
		Initialize variable mat15 as double with element 15 in matrix . 
		Assign element 0 in matrix  * x of offset  + element 4 in matrix  * y of offset  + element 8 in matrix  * z of offset  + mat12 to element 12 in matrix . 
		Assign element 1 in matrix  * x of offset  + element 5 in matrix  * y of offset  + element 9 in matrix  * z of offset  + mat13 to element 13 in matrix . 
		Assign element 2 in matrix  * x of offset  + element 6 in matrix  * y of offset  + element 10 in matrix  * z of offset  + mat13 to element 14 in matrix . 
		Assign element 3 in matrix  * x of offset  + element 7 in matrix  * y of offset  + element 11 in matrix  * z of offset  + mat15 to element 15 in matrix . 
	ending here 
	Declare function ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ that takes axis as Vector3D , theta as double with code starting here
		Call normalize of axis . 
		Initialize variable s as double with sin ( theta ) . 
		Initialize variable c as double with cos ( theta ) . 
		Initialize variable t as double with 1.0  - c . 
		Initialize variable a00 as double with element 0 in matrix . 
		Initialize variable a01 as double with element 1 in matrix . 
		Initialize variable a02 as double with element 2 in matrix . 
		Initialize variable a03 as double with element 3 in matrix . 
		Initialize variable a10 as double with element 4 in matrix . 
		Initialize variable a11 as double with element 5 in matrix . 
		Initialize variable a12 as double with element 6 in matrix . 
		Initialize variable a13 as double with element 7 in matrix . 
		Initialize variable a20 as double with element 8 in matrix . 
		Initialize variable a21 as double with element 9 in matrix . 
		Initialize variable a22 as double with element 10 in matrix . 
		Initialize variable a23 as double with element 11 in matrix . 
		Initialize variable b00 as double with x of axis  * x of axis  * t  + c . 
		Initialize variable b01 as double with y of axis  * x of axis  * t  + z of axis  * s . 
		Initialize variable b02 as double with z of axis  * x of axis  * t  - y of axis  * s . 
		Initialize variable b10 as double with x of axis  * y of axis  * t  - z of axis  * s . 
		Initialize variable b11 as double with y of axis  * y of axis  * t  + c . 
		Initialize variable b12 as double with z of axis  * y of axis  * t  + x of axis  * s . 
		Initialize variable b20 as double with x of axis  * z of axis  * t  + y of axis  * s . 
		Initialize variable b21 as double with y of axis  * z of axis  * t  - x of axis  * s . 
		Initialize variable b22 as double with z of axis  * z of axis  * t  + c . 
		Assign a00  * b00  + a10  * b01  + a20  * b02 to element 0 in matrix . 
		Assign a01  * b00  + a11  * b01  + a21  * b02 to element 1 in matrix . 
		Assign a02  * b00  + a12  * b01  + a22  * b02 to element 2 in matrix . 
		Assign a03  * b00  + a13  * b01  + a23  * b02 to element 3 in matrix . 
		Assign a00  * b10  + a10  * b11  + a20  * b12 to element 4 in matrix . 
		Assign a01  * b10  + a11  * b11  + a21  * b12 to element 5 in matrix . 
		Assign a02  * b10  + a12  * b11  + a22  * b12 to element 6 in matrix . 
		Assign a03  * b10  + a13  * b11  + a23  * b12 to element 7 in matrix . 
		Assign a00  * b20  + a10  * b21  + a20  * b22 to element 8 in matrix . 
		Assign a01  * b20  + a11  * b21  + a21  * b22 to element 9 in matrix . 
		Assign a02  * b20  + a12  * b21  + a22  * b22 to element 10 in matrix . 
		Assign a03  * b20  + a13  * b21  + a23  * b22 to element 11 in matrix . 
	ending here 
	Declare function ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ that takes x as double , y as double , z as double with code starting here
		Assign element 0 in matrix  * x to element 0 in matrix . 
		Assign element 1 in matrix  * x to element 1 in matrix . 
		Assign element 2 in matrix  * x to element 2 in matrix . 
		Assign element 3 in matrix  * x to element 3 in matrix . 
		Assign element 4 in matrix  * y to element 4 in matrix . 
		Assign element 5 in matrix  * y to element 5 in matrix . 
		Assign element 6 in matrix  * y to element 6 in matrix . 
		Assign element 7 in matrix  * y to element 7 in matrix . 
		Assign element 8 in matrix  * z to element 8 in matrix . 
		Assign element 9 in matrix  * z to element 9 in matrix . 
		Assign element 10 in matrix  * z to element 10 in matrix . 
		Assign element 11 in matrix  * z to element 11 in matrix . 
	ending here 
ending here 
Declare function ${"ja":"カメラ行列", "natja":"カメラ行列", "en":"setCameraMat", "naten":"setCameraMat"}$ that takes m as Matrix4x4 , pos as Vector3D , lookAt as Vector3D , up as Vector3D and returns res as Matrix4x4 with code starting here
	Initialize object newForward as Vector3D with x of lookAt  - x of pos , y of lookAt  - y of pos , z of lookAt  - z of pos . 
	Initialize object a as Vector3D with 0.0 , 0.0 , 0.0 . 
	Assign extendVector3D ( newForward , dotVector3D ( up , newForward ) ) to a . 
	Initialize object newUp as Vector3D with x of up  - x of a , y of up  - y of a , z of up  - z of a . 
	Call normalize of newUp . 
	Initialize object newRight as Vector3D with 0 , 0 , 0 . 
	Assign crossVector3D ( newUp , newForward ) to newRight . 
	Assign [ x of newRight , x of newUp , x of newForward , 0.0 , y of newRight , y of newUp , y of newForward , 0.0 , z of newRight , z of newUp , z of newForward , 0.0 , 0  - dotVector3D ( newRight , pos ) , 0  - dotVector3D ( newUp , pos ) , 0  - dotVector3D ( newForward , pos ) , 1.0 ] to matrix of m . 
	Return value m . 
ending here 
Declare function ${"ja":"視点行列3D", "natja":"視点行列3D", "en":"perspectiveMat3D", "naten":"perspectiveMat3D"}$ that takes m as Matrix4x4 , fov as double , width as double , height as double , zN as double , zF as double and returns result as Matrix4x4 with code starting here
	Initialize variable PI as double with 3.14159265358979312 . 
	Initialize variable fov as double with 1.0  / tan ( ( 90.0  / 360.0 )  * PI ) . 
	Initialize variable aspectRatio as double with width  / height . 
	Initialize variable zNear as double with zN . 
	Initialize variable zFar as double with zF . 
	Initialize variable zQ as double with zF  / ( zF  - zN ) . 
	Assign [ aspectRatio  * fov , 0.0 , 0.0 , 0.0 , 0.0 , fov , 0.0 , 0.0 , 0.0 , 0.0 , zQ , 1.0 , 0.0 , 0.0 , ( 0  - zFar  * zNear )  / ( zFar  - zNear ) , 0.0 ] to matrix of m . 
	Return value m . 
ending here 
Declare function ${"ja":"視点行列2D", "natja":"視点行列2D", "en":"perspectiveMat2D", "naten":"perspectiveMat2D"}$ that takes m as Matrix4x4 , left as double , right as double , bottom as double , top as double , near as double , far as double and returns result as Matrix4x4 with code starting here
	Assign [ 2.0  / ( right  - left ) , 0.0 , 0.0 , 0.0 , 0.0 , 2.0  / ( top  - bottom ) , 0.0 , 0.0 , 0.0 , 0.0 , 0  - 2.0  / ( near  - far ) , 0.0 , 0  - ( right  + left )  / ( right  - left ) , 0  - ( top  + bottom )  / ( top  - bottom ) , 0  - ( far  + near )  / ( far  - near ) , 1.0 ] to matrix of m . 
	Return value m . 
ending here 
Declare function ${"ja":"行列4x4の積", "natja":"行列4x4の積", "en":"mulMatrix4x4", "naten":"mulMatrix4x4"}$ that takes a as Matrix4x4 , b as Matrix4x4 and returns out as Matrix4x4 with code starting here
	Assign element 0 in matrix of b  * element 0 in matrix of a  + element 1 in matrix of b  * element 4 in matrix of a  + element 2 in matrix of b  * element 8 in matrix of a  + element 3 in matrix of b  * element 12 in matrix of a to element 0 in matrix of out . 
	Assign element 0 in matrix of b  * element 1 in matrix of a  + element 1 in matrix of b  * element 5 in matrix of a  + element 2 in matrix of b  * element 9 in matrix of a  + element 3 in matrix of b  * element 13 in matrix of a to element 1 in matrix of out . 
	Assign element 0 in matrix of b  * element 2 in matrix of a  + element 1 in matrix of b  * element 6 in matrix of a  + element 2 in matrix of b  * element 10 in matrix of a  + element 3 in matrix of b  * element 14 in matrix of a to element 2 in matrix of out . 
	Assign element 0 in matrix of b  * element 3 in matrix of a  + element 1 in matrix of b  * element 7 in matrix of a  + element 2 in matrix of b  * element 11 in matrix of a  + element 3 in matrix of b  * element 15 in matrix of a to element 3 in matrix of out . 
	Assign element 4 in matrix of b  * element 0 in matrix of a  + element 5 in matrix of b  * element 4 in matrix of a  + element 6 in matrix of b  * element 8 in matrix of a  + element 7 in matrix of b  * element 12 in matrix of a to element 4 in matrix of out . 
	Assign element 4 in matrix of b  * element 1 in matrix of a  + element 5 in matrix of b  * element 5 in matrix of a  + element 6 in matrix of b  * element 9 in matrix of a  + element 7 in matrix of b  * element 13 in matrix of a to element 5 in matrix of out . 
	Assign element 4 in matrix of b  * element 2 in matrix of a  + element 5 in matrix of b  * element 6 in matrix of a  + element 6 in matrix of b  * element 10 in matrix of a  + element 7 in matrix of b  * element 14 in matrix of a to element 6 in matrix of out . 
	Assign element 4 in matrix of b  * element 3 in matrix of a  + element 5 in matrix of b  * element 7 in matrix of a  + element 6 in matrix of b  * element 11 in matrix of a  + element 7 in matrix of b  * element 15 in matrix of a to element 7 in matrix of out . 
	Assign element 8 in matrix of b  * element 0 in matrix of a  + element 9 in matrix of b  * element 4 in matrix of a  + element 10 in matrix of b  * element 8 in matrix of a  + element 11 in matrix of b  * element 12 in matrix of a to element 8 in matrix of out . 
	Assign element 8 in matrix of b  * element 1 in matrix of a  + element 9 in matrix of b  * element 5 in matrix of a  + element 10 in matrix of b  * element 9 in matrix of a  + element 11 in matrix of b  * element 13 in matrix of a to element 9 in matrix of out . 
	Assign element 8 in matrix of b  * element 2 in matrix of a  + element 9 in matrix of b  * element 6 in matrix of a  + element 10 in matrix of b  * element 10 in matrix of a  + element 11 in matrix of b  * element 14 in matrix of a to element 10 in matrix of out . 
	Assign element 8 in matrix of b  * element 3 in matrix of a  + element 9 in matrix of b  * element 7 in matrix of a  + element 10 in matrix of b  * element 11 in matrix of a  + element 11 in matrix of b  * element 15 in matrix of a to element 11 in matrix of out . 
	Assign element 12 in matrix of b  * element 0 in matrix of a  + element 13 in matrix of b  * element 4 in matrix of a  + element 14 in matrix of b  * element 8 in matrix of a  + element 15 in matrix of b  * element 12 in matrix of a to element 12 in matrix of out . 
	Assign element 12 in matrix of b  * element 1 in matrix of a  + element 13 in matrix of b  * element 5 in matrix of a  + element 14 in matrix of b  * element 9 in matrix of a  + element 15 in matrix of b  * element 13 in matrix of a to element 13 in matrix of out . 
	Assign element 12 in matrix of b  * element 2 in matrix of a  + element 13 in matrix of b  * element 6 in matrix of a  + element 14 in matrix of b  * element 10 in matrix of a  + element 15 in matrix of b  * element 14 in matrix of a to element 14 in matrix of out . 
	Assign element 12 in matrix of b  * element 3 in matrix of a  + element 13 in matrix of b  * element 7 in matrix of a  + element 14 in matrix of b  * element 11 in matrix of a  + element 15 in matrix of b  * element 15 in matrix of a to element 15 in matrix of out . 
ending here 
Declare class ${"ja":"モデル", "natja":"モデル", "en":"Model", "naten":"Model"}$ with members starting here
public : 	Declare variable ${"ja":"色", "natja":"色", "en":"color", "naten":"color"}$ as Vector3D . 
	Declare variable ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$ as Vector3D . 
	Declare function Model that takes data as pointer of double , num as int , c as Vector3D , p as Vector3D , s as int with code starting here
		Assign data to vertices . 
		Assign num to vertexNum . 
		Assign c to color . 
		Assign p to pos . 
		Assign s to shaderID . 
		Call identity of modelMat . 
		Call identity of transMat . 
		Call identity of scaleMat . 
		Call identity of rotateMat . 
		Initialize variable element 8 in _lightPosUniform as char with "lightPos". 
		Initialize variable element 8 in _viewPosUniform as char with "viewPos". 
		Initialize variable element 10 in _lightColorUniform as char with "lightColor". 
		Initialize variable element 11 in _objectColorUniform as char with "objectColor". 
		Initialize variable element 8 in _projUniform as char with "uProjMat". 
		Initialize variable element 8 in _viewUniform as char with "uViewMat". 
		Initialize variable element 9 in _modelUniform as char with "uModelMat". 
		Initialize object lightPosUniform as string with & _lightPosUniform , 8 . 
		Initialize object viewPosUniform as string with & _viewPosUniform , 7 . 
		Initialize object lightColorUniform as string with & _lightColorUniform , 10 . 
		Initialize object objectColorUniform as string with & _objectColorUniform , 11 . 
		Initialize object projUniform as string with & _projUniform , 8 . 
		Initialize object viewUniform as string with & _viewUniform , 8 . 
		Initialize object modelUniform as string with & _modelUniform , 9 . 
		If shaderID  is 0 then execute code starting here
			Assign glGetUniformLocation ( 0 , viewPosUniform ) to viewPosUniLoc . 
			Assign glGetUniformLocation ( 0 , lightPosUniform ) to lightPosUniLoc . 
			Assign glGetUniformLocation ( 0 , lightColorUniform ) to lightColorUniLoc . 
			Assign glGetUniformLocation ( 0 , objectColorUniform ) to objectColorUniLoc . 
		ending here 
		Assign glGetUniformLocation ( shaderID , projUniform ) to projMatUniformLoc . 
		Assign glGetUniformLocation ( shaderID , viewUniform ) to viewMatUniformLoc . 
		Assign glGetUniformLocation ( shaderID , modelUniform ) to modelMatUniformLoc . 
		Assign glCreateBuffer ( ) to buffer . 
		Call glBindBuffer with value 34962 , buffer . 
		Call glBufferData with value 34962 , vertices , num  * 6 , 35044 . 
	ending here 
	Declare function ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ that takes coord as Vector3D with code starting here
		Assign coord to pos . 
	ending here 
	Declare function ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ that takes offset as Vector3D with code starting here
		Assign addVector3D ( pos , offset ) to pos . 
	ending here 
	Declare function ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ that takes x as double , y as double , z as double with code starting here
		Initialize object temp as Matrix4x4 with . 
		Call identity of temp . 
		Call scale of temp with value x , y , z . 
		Assign mulMatrix4x4 ( temp , scaleMat ) to scaleMat . 
	ending here 
	Declare function ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ that takes axis as Vector3D , t as double with code starting here
		Initialize object temp as Matrix4x4 with . 
		Call identity of temp . 
		Call rotate of temp with value axis , t . 
		Assign mulMatrix4x4 ( temp , rotateMat ) to rotateMat . 
	ending here 
	Declare function ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ that takes projMat as Matrix4x4 , viewMat as Matrix4x4 , camera as Vector3D with code starting here
		Initialize variable PI as double with 3.14159265358979312 . 
		Call translate of transMat with value pos . 
		Call identity of modelMat . 
		Assign mulMatrix4x4 ( scaleMat , modelMat ) to modelMat . 
		Assign mulMatrix4x4 ( rotateMat , modelMat ) to modelMat . 
		Assign mulMatrix4x4 ( transMat , modelMat ) to modelMat . 
		Call glBindBuffer with value 34962 , buffer . 
		Call glEnableVertexAttribArray with value 0 . 
		Call glVertexAttribPointer with value 0 , 3 , 5126 , 0 , 6  * 4 , 0 . 
		Call glEnableVertexAttribArray with value 1 . 
		Call glVertexAttribPointer with value 1 , 3 , 5126 , 0 , 6  * 4 , 3  * 4 . 
		Call glUseProgram with value shaderID . 
		If shaderID  is 0 then execute code starting here
			Call glUniform3f with value lightPosUniLoc , 5.0 , 5.0 , 5.0 . 
			Call glUniform3f with value lightColorUniLoc , 1.0 , 1.0 , 1.0 . 
			Call glUniform3f with value objectColorUniLoc , x of color , y of color , z of color . 
			Call glUniform3f with value viewPosUniLoc , x of camera , y of camera , z of camera . 
		ending here 
		Call glUniformMatrix4fv with value projMatUniformLoc , 0 , matrix of projMat . 
		Call glUniformMatrix4fv with value viewMatUniformLoc , 0 , matrix of viewMat . 
		Call glUniformMatrix4fv with value modelMatUniformLoc , 0 , matrix of modelMat . 
		Call glDrawArrays with value 4 , 0 , 36 . 
		Call identity of rotateMat . 
		Call identity of transMat . 
		Call identity of scaleMat . 
	ending here 
private : 	Declare variable vertices as pointer of double . 
	Declare variable vertexNum as int . 
	Declare variable buffer as short . 
	Declare variable modelMat as Matrix4x4 . 
	Declare variable transMat as Matrix4x4 . 
	Declare variable scaleMat as Matrix4x4 . 
	Declare variable rotateMat as Matrix4x4 . 
	Declare variable shaderID as int . 
	Declare variable viewPosUniLoc as short . 
	Declare variable lightPosUniLoc as short . 
	Declare variable lightColorUniLoc as short . 
	Declare variable objectColorUniLoc as short . 
	Declare variable projMatUniformLoc as short . 
	Declare variable viewMatUniformLoc as short . 
	Declare variable modelMatUniformLoc as short . 
ending here 
Declare class ${"ja":"カメラ", "natja":"カメラ", "en":"Camera", "naten":"Camera"}$ with members starting here
public : 	Declare variable ${"ja":"座標", "natja":"座標", "en":"pos", "naten":"pos"}$ as Vector3D . 
	Declare variable ${"ja":"感度", "natja":"感度", "en":"sensitivity", "naten":"sensitivity"}$ as double . 
	Declare function Camera that takes p as Vector3D with code starting here
		Assign p to pos . 
		Call Vector3D of view with value 0.0 , 0.0 , 1.0 . 
		Call Vector3D of lookDir with value 0.0 , 0.0 , 1.0 . 
		Call Vector3D of up with value 0.0 , 1.0 , 0.0 . 
		Assign 90.0 to yaw . 
		Assign 0.0 to pitch . 
		Assign 0.100000000000000006 to sensitivity . 
	ending here 
	Declare function ${"ja":"感度設定", "natja":"感度設定", "en":"setSensitivity", "naten":"setSensitivity"}$ that takes s as double with code starting here
		Assign s to sensitivity . 
	ending here 
	Declare function ${"ja":"アップデート", "natja":"アップデート", "en":"update", "naten":"update"}$ that takes xOffset as double , yOffset as double , elapsedTime as double and returns result as Matrix4x4 with code starting here
		If checkKeyPress ( 32 )  is 1 then execute code starting here
			Assign y of pos  + elapsedTime  * 5.0 to y of pos . 
		ending here 
		If checkKeyPress ( 16 )  is 1 then execute code starting here
			Assign y of pos  - elapsedTime  * 5.0 to y of pos . 
		ending here 
		If checkKeyPress ( 65 )  is 1 then execute code starting here
			Assign z of pos  - elapsedTime  * sin ( toRad ( yaw  - 90 ) )  * 5.0 to z of pos . 
			Assign x of pos  - elapsedTime  * cos ( toRad ( yaw  - 90 ) )  * 5.0 to x of pos . 
		ending here 
		If checkKeyPress ( 68 )  is 1 then execute code starting here
			Assign z of pos  + elapsedTime  * sin ( toRad ( yaw  - 90 ) )  * 5.0 to z of pos . 
			Assign x of pos  + elapsedTime  * cos ( toRad ( yaw  - 90 ) )  * 5.0 to x of pos . 
		ending here 
		If checkKeyPress ( 87 )  is 1 then execute code starting here
			Assign z of pos  + elapsedTime  * sin ( toRad ( yaw ) )  * 5.0 to z of pos . 
			Assign x of pos  + elapsedTime  * cos ( toRad ( yaw ) )  * 5.0 to x of pos . 
		ending here 
		If checkKeyPress ( 83 )  is 1 then execute code starting here
			Assign z of pos  - elapsedTime  * sin ( toRad ( yaw ) )  * 5.0 to z of pos . 
			Assign x of pos  - elapsedTime  * cos ( toRad ( yaw ) )  * 5.0 to x of pos . 
		ending here 
		Assign yaw  - xOffset  * sensitivity to yaw . 
		Assign pitch  - yOffset  * sensitivity to pitch . 
		If pitch  < 0  - 89.0 then execute code starting here
			Assign 0  - 89.0 to pitch . 
		ending here 
		If pitch  > 89.0 then execute code starting here
			Assign 89.0 to pitch . 
		ending here 
		Assign cos ( toRad ( yaw ) )  * cos ( toRad ( pitch ) ) to x of lookDir . 
		Assign sin ( toRad ( pitch ) ) to y of lookDir . 
		Assign sin ( toRad ( yaw ) )  * cos ( toRad ( pitch ) ) to z of lookDir . 
		Call normalize of lookDir . 
		Call identity of result . 
		Assign addVector3D ( lookDir , pos ) to view . 
		Assign setCameraMat ( result , pos , view , up ) to result . 
	ending here 
private : 	Declare variable view as Vector3D . 
	Declare variable lookDir as Vector3D . 
	Declare variable up as Vector3D . 
	Declare variable yaw as double . 
	Declare variable pitch as double . 
ending here 
Declare class ${"ja":"シーン", "natja":"シーン", "en":"Scene", "naten":"Scene"}$ with members starting here
public : 	Declare variable ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$ as Array < pointer of Model > . 
	Declare variable ${"ja":"目", "natja":"目", "en":"camera", "naten":"camera"}$ as Camera . 
	Declare function Scene with code starting here
		Assign getTime ( )  / 1000.0 to last . 
		Assign 0.0 to now . 
		Assign 0.0 to elapsedTime . 
		Assign checkAbsoluteMouseX ( ) to lastX . 
		Assign checkAbsoluteMouseY ( ) to lastY . 
		Call identity of projMat . 
		Call identity of viewMat . 
		Assign perspectiveMat3D ( projMat , 90.0 , 720.0 , 1280.0 , 0.100000000000000006 , 100.0 ) to projMat . 
		Initialize object temp as Vector3D with 0.0 , 0.0 , 0  - 4.0 . 
		Call Camera of camera with value temp . 
		Call Array of sprites . 
	ending here 
	Declare function ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ with code starting here
		Assign getTime ( )  / 1000.0 to now . 
		Assign now  - last to elapsedTime . 
		Assign now to last . 
		Call glClearColor with value 0.0 , 0.0 , 0.0 , 1.0 . 
		Call glClearDepth with value 1.0 . 
		Call glEnable with value 2929 . 
		Call glDepthFunc with value 515 . 
		Call glClear with value 16640 . 
		Initialize variable xOffset as double with checkAbsoluteMouseX ( )  - lastX . 
		Initialize variable yOffset as double with checkAbsoluteMouseY ( )  - lastY . 
		Assign checkAbsoluteMouseX ( ) to lastX . 
		Assign checkAbsoluteMouseY ( ) to lastY . 
		Call identity of viewMat . 
		Assign update of camera ( xOffset , yOffset , elapsedTime ) to viewMat . 
		( Initialize variable i as int with 0 . ) from ( i  is size of sprites ) to ( Assign i  + 1 to i . ) starting here
			Call get of sprites ( i ) -> draw with value projMat , viewMat , pos of camera . 
		ending here 
	ending here 
	Declare function ${"ja":"キューブ追加", "natja":"キューブ追加", "en":"addCube", "naten":"addCube"}$ that takes size as double , color as Vector3D , pos as Vector3D and returns id as int with code starting here
		Initialize variable element 6 in element 3 in element 12 in vertices as double with [ [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] ] . 
		Initialize variable cube as pointer of Model with allocMemory ( sizeof ( variable at cube ) ) . 
		Call cube -> Model with value & vertices , 36 , color , pos , 0 . 
		Call push of sprites with value cube . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"ライト追加", "natja":"ライト追加", "en":"addLight", "naten":"addLight"}$ that takes size as double , color as Vector3D , pos as Vector3D and returns id as int with code starting here
		Initialize variable element 6 in element 3 in element 12 in vertices as double with [ [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0.0 , 0  - 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , size  / 2 , 1.0 , 0.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0.0 , 1.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0  - 1.0 , 0.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ 0  - size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ 0  - size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , size  / 2 , 0.0 , 1.0 , 0.0 ] , [ size  / 2 , size  / 2 , 0  - size  / 2 , 0.0 , 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] , [ [ size  / 2 , 0  - size  / 2 , size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] , [ size  / 2 , 0  - size  / 2 , 0  - size  / 2 , 0.0 , 0  - 1.0 , 0.0 ] ] ] . 
		Initialize variable light as pointer of Model with allocMemory ( sizeof ( variable at light ) ) . 
		Call light -> Model with value & vertices , 36 , color , pos , 1 . 
		Call push of sprites with value light . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
private : 	Declare variable projMat as Matrix4x4 . 
	Declare variable viewMat as Matrix4x4 . 
	Declare variable last as double . 
	Declare variable now as double . 
	Declare variable elapsedTime as double . 
	Declare variable lastX as double . 
	Declare variable lastY as double . 
ending here 
Declare class ${"ja":"ベクトル2D", "natja":"ベクトル2D", "en":"Vector2D", "naten":"Vector2D"}$ with members starting here
public : 	Declare variable x as double . 
	Declare variable y as double . 
	Declare function Vector2D that takes a as double , b as double with code starting here
		Assign a to x . 
		Assign b to y . 
	ending here 
	Declare function ${"ja":"長さ", "natja":"長さ", "en":"length", "naten":"length"}$ that returns l as double with code starting here
		Assign root ( x  * x  + y  * y ) to l . 
	ending here 
	Declare function ${"ja":"正規化", "natja":"正規化", "en":"normalize", "naten":"normalize"}$ with code starting here
		Initialize variable l as double with root ( x  * x  + y  * y ) . 
		Assign x  / l to x . 
		Assign y  / l to y . 
	ending here 
ending here 
Declare function ${"ja":"ベクトル2Dの和", "natja":"ベクトル2Dの和", "en":"addVector2D", "naten":"addVector2D"}$ that takes a as Vector2D , b as Vector2D and returns result as Vector2D with code starting here
	Assign x of a  + x of b to x of result . 
	Assign y of a  + y of b to y of result . 
ending here 
Declare function ${"ja":"ベクトル2Dの差", "natja":"ベクトル2Dの差", "en":"subVector2D", "naten":"subVector2D"}$ that takes a as Vector2D , b as Vector2D and returns result as Vector2D with code starting here
	Assign x of a  - x of b to x of result . 
	Assign y of a  - y of b to y of result . 
ending here 
Declare function ${"ja":"ベクトル2Dの内積", "natja":"ベクトル2Dの内積", "en":"dotVector2D", "naten":"dotVector2D"}$ that takes a as Vector2D , b as Vector2D and returns x as double with code starting here
	Assign x of a  * x of b  + y of a  * y of b to x . 
ending here 
Declare function ${"ja":"ベクトル2D拡大", "natja":"ベクトル2D拡大", "en":"extendVector2D", "naten":"extendVector2D"}$ that takes a as Vector2D , x as double and returns result as Vector2D with code starting here
	Assign x of a  * x to x of result . 
	Assign y of a  * x to y of result . 
ending here 
Declare function ${"ja":"ベクトル2D縮小", "natja":"ベクトル2D縮小", "en":"divVector2D", "naten":"divVector2D"}$ that takes a as Vector2D , x as double and returns result as Vector2D with code starting here
	If x  is 0.0 then execute code starting here
		Call print with value 10000000 . 
	ending here 
	Assign x of a  / x to x of result . 
	Assign y of a  / x to y of result . 
ending here 
Declare class ${"ja":"アニメーション情報", "natja":"アニメーション情報", "en":"AnimationInfo", "naten":"AnimationInfo"}$ with members starting here
public : 	Declare variable id as int . 
	Declare variable startTime as double . 
	Declare variable duration as double . 
	Declare variable info as Vector2D . 
	Declare function AnimationInfo that takes a as int , start as double , d as double , x as double , y as double with code starting here
		Assign a to id . 
		Assign start to startTime . 
		Assign d to duration . 
		Assign x to x of info . 
		Assign y to y of info . 
	ending here 
ending here 
Declare class ${"ja":"スプライト", "natja":"スプライト", "en":"Sprite", "naten":"Sprite"}$ with members starting here
public : 	Declare variable color as Vector3D . 
	Declare variable pos as Vector2D . 
	Declare variable 透明度 as double . 
	Declare variable scaleX as double . 
	Declare variable scaleY as double . 
	Declare variable theta as double . 
	Declare function Sprite that takes data as pointer of double , pnum as int , indicesData as pointer of short , vnum as int , c as Vector3D , p as Vector2D , s as int , zI as double with code starting here
		Assign data to vertices . 
		Assign pnum to pointNum . 
		Assign indicesData to indices . 
		Assign vnum to vertexNum . 
		Assign zI to zIndex . 
		Assign 1.0 to 透明度 . 
		Assign c to color . 
		Assign p to pos . 
		Assign 1.0 to scaleX . 
		Assign 1.0 to scaleY . 
		Assign 0.0 to theta . 
		Assign s to shaderID . 
		Call Array of animations . 
		Call identity of modelMat . 
		Call identity of transMat . 
		Call identity of scaleMat . 
		Call identity of rotateMat . 
		Initialize variable element 11 in _objectColorUniform as char with "objectColor". 
		Initialize variable element 10 in _projUniform as char with "projection". 
		Initialize variable element 5 in _modelUniform as char with "model". 
		Initialize variable element 8 in _samplerUniform as char with "uSampler". 
		Initialize variable element 12 in _transparencyUniform as char with "transparency". 
		Initialize object objectColorUniform as string with & _objectColorUniform , 11 . 
		Initialize object projUniform as string with & _projUniform , 10 . 
		Initialize object modelUniform as string with & _modelUniform , 5 . 
		Initialize object samplerUniform as string with & _samplerUniform , 8 . 
		Initialize object transparencyUniform as string with & _transparencyUniform , 12 . 
		Assign glGetUniformLocation ( shaderID , projUniform ) to projMatUniformLoc . 
		Assign glGetUniformLocation ( shaderID , modelUniform ) to modelMatUniformLoc . 
		If shaderID  is 4 then execute code starting here
			Assign glGetUniformLocation ( shaderID , transparencyUniform ) to transparencyUniLoc . 
			Assign glGetUniformLocation ( shaderID , objectColorUniform ) to objectColorUniLoc . 
		ending here 
		If shaderID  is 3 then execute code starting here
			Assign glGetUniformLocation ( shaderID , samplerUniform ) to samplerUniformLoc . 
		ending here 
		Assign glCreateBuffer ( ) to buffer . 
		Call glBindBuffer with value 34962 , buffer . 
		Call glBufferData with value 34962 , vertices , pnum  * 3 , 35044 . 
		If vnum  > 0 then execute code starting here
			Assign glCreateBuffer ( ) to elementBuffer . 
			Call glBindBuffer with value 34963 , elementBuffer . 
			Call glElementBufferData with value 34963 , indices , vnum , 35044 . 
		ending here 
	ending here 
	Declare function ${"ja":"テクスチャ設定", "natja":"テクスチャ設定", "en":"setTexture", "naten":"setTexture"}$ that takes tex as pointer of double , url as string with code starting here
		Assign 0 to shaderID . 
		Assign tex to texCoords . 
		Assign _loadTexture ( content of url , length of url ) to texture . 
		Call _printString with value content of url , length of url . 
		Assign glCreateBuffer ( ) to texCoordBuffer . 
		Call glBindBuffer with value 34962 , texCoordBuffer . 
		Call glBufferData with value 34962 , tex , vertexNum  * 2 , 35044 . 
	ending here 
	Declare function ${"ja":"リピートテクスチャ設定", "natja":"リピートテクスチャ設定", "en":"setRepeatTexture", "naten":"setRepeatTexture"}$ that takes tex as pointer of double , テクスチャ as short with code starting here
		Assign 0 to shaderID . 
		Assign tex to texCoords . 
		Assign テクスチャ to texture . 
		Assign glCreateBuffer ( ) to texCoordBuffer . 
		Call glBindBuffer with value 34962 , texCoordBuffer . 
		Call glBufferData with value 34962 , tex , vertexNum  * 2 , 35044 . 
	ending here 
	Declare function ${"ja":"座標設定", "natja":"座標設定", "en":"setPos", "naten":"setPos"}$ that takes coord as Vector2D with code starting here
		Assign coord to pos . 
	ending here 
	Declare function ${"ja":"移動", "natja":"移動", "en":"translate", "naten":"translate"}$ that takes offset as Vector2D with code starting here
		Assign addVector2D ( pos , offset ) to pos . 
	ending here 
	Declare function ${"ja":"拡大縮小", "natja":"拡大縮小", "en":"scale", "naten":"scale"}$ that takes x as double , y as double with code starting here
		Assign scaleX  * x to scaleX . 
		Assign scaleY  * y to scaleY . 
	ending here 
	Declare function ${"ja":"回転", "natja":"回転", "en":"rotate", "naten":"rotate"}$ that takes t as double with code starting here
		Assign theta  + t to theta . 
	ending here 
	Declare function ${"ja":"角度設定", "natja":"角度設定", "en":"setAngle", "naten":"setAngle"}$ that takes t as double with code starting here
		Assign t to theta . 
	ending here 
	Declare function ${"ja":"zIndex設定", "natja":"zIndex設定", "en":"setZIndex", "naten":"setZIndex"}$ that takes x as double with code starting here
		Assign x to zIndex . 
	ending here 
	Declare function ${"ja":"透明度設定", "natja":"透明度設定", "en":"setTransparency", "naten":"setTransparency"}$ that takes x as double with code starting here
		Assign x to 透明度 . 
	ending here 
	Declare function ${"ja":"色設定", "natja":"色設定", "en":"setColor", "naten":"setColor"}$ that takes color as Vector3D with code starting here
		Assign color to color . 
	ending here 
	Declare function ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ that takes projMat as Matrix4x4 with code starting here
		Initialize variable PI as double with 3.14159265358979312 . 
		( Initialize variable カウンタ as int with 0 . ) from ( カウンタ  is size of animations ) to ( Assign カウンタ  + 1 to カウンタ . ) starting here
			Initialize variable info as AnimationInfo with get of animations ( カウンタ ) . 
			If ( startTime of info  <= getTime ( ) )  && ( ( startTime of info  + duration of info )  >= getTime ( ) ) then execute code starting here
				If id of info  is 0 then execute code starting here
					Initialize variable elapsedTime as double with getTime ( )  - startTime of info . 
					Call rotate with value x of info of info  * elapsedTime . 
				ending here 
				If id of info  is 1 then execute code starting here
					Call scale with value x of info of info , y of info of info . 
				ending here 
				If id of info  is 2 then execute code starting here
					Initialize variable elapsedTime as double with getTime ( )  - startTime of info . 
					Initialize object offset as Vector2D with x of info of info  * elapsedTime , y of info of info  * elapsedTime . 
					Call translate with value offset . 
				ending here 
			ending here 
		ending here 
		Initialize object pos3d as Vector3D with x of pos , y of pos , 0  - zIndex  * 0.00100000000000000002 . 
		Call identity of transMat . 
		Call translate of transMat with value pos3d . 
		Call identity of scaleMat . 
		Call scale of scaleMat with value scaleX , scaleY , 1.0 . 
		Initialize object 回転軸 as Vector3D with 0.0 , 0.0 , 1.0 . 
		Call identity of rotateMat . 
		Call rotate of rotateMat with value 回転軸 , theta . 
		Call identity of modelMat . 
		Assign mulMatrix4x4 ( scaleMat , modelMat ) to modelMat . 
		Assign mulMatrix4x4 ( rotateMat , modelMat ) to modelMat . 
		Assign mulMatrix4x4 ( transMat , modelMat ) to modelMat . 
		Call glUseProgram with value shaderID . 
		Call glBindBuffer with value 34962 , buffer . 
		Call glEnableVertexAttribArray with value 0 . 
		Call glVertexAttribPointer with value 0 , 3 , 5126 , 0 , 0 , 0 . 
		If shaderID  is 4 then execute code starting here
			Call glUniform1f with value transparencyUniLoc , 透明度 . 
			Call glUniform3f with value objectColorUniLoc , x of color , y of color , z of color . 
		ending here 
		If shaderID  is 3 then execute code starting here
			Call glBindBuffer with value 34962 , texCoordBuffer . 
			Call glEnableVertexAttribArray with value 1 . 
			Call glVertexAttribPointer with value 1 , 2 , 5126 , 0 , 0 , 0 . 
			Call glActiveTexture with value texture  + 33984 . 
			Call glBindTexture with value 3553 , texture . 
			Call glUniform1i with value samplerUniformLoc , texture . 
		ending here 
		Call glUniformMatrix4fv with value projMatUniformLoc , 0 , matrix of projMat . 
		Call glUniformMatrix4fv with value modelMatUniformLoc , 0 , matrix of modelMat . 
		If vertexNum  > 0 then execute code starting here
			Call glBindBuffer with value 34963 , elementBuffer . 
			Call glDrawElements with value 4 , vertexNum , 5123 , 0 . 
		ending here 
		If ( vertexNum  is 0 )  && ( shaderID  is 4 ) then execute code starting here
			Call glBindBuffer with value 34962 , buffer . 
			Call glDrawArrays with value 5 , 0 , pointNum . 
		ending here 
		Call identity of rotateMat . 
		Call identity of transMat . 
		Call identity of scaleMat . 
	ending here 
	Declare function ${"ja":"回転アニメーション", "natja":"回転アニメーション", "en":"rotateAnimation", "naten":"rotateAnimation"}$ that takes theta as double , start as double , duration as double with code starting here
		Initialize object temp as AnimationInfo with 0 , start , duration , theta , 0.0 . 
		Call push of animations with value temp . 
	ending here 
	Declare function ${"ja":"拡大縮小設定", "natja":"拡大縮小設定", "en":"scaleAnimation", "naten":"scaleAnimation"}$ that takes x as double , y as double , start as double , duration as double with code starting here
		Initialize object temp as AnimationInfo with 1 , start , duration , x , y . 
		Call push of animations with value temp . 
	ending here 
	Declare function ${"ja":"移動アニメーション", "natja":"移動アニメーション", "en":"translateAnimation", "naten":"translateAnimation"}$ that takes offset as Vector2D , start as double , duration as double with code starting here
		Initialize object temp as AnimationInfo with 0 , start , duration , x of offset , y of offset . 
		Call push of animations with value temp . 
	ending here 
private : 	Declare variable vertices as pointer of double . 
	Declare variable indices as pointer of short . 
	Declare variable texCoords as pointer of double . 
	Declare variable vertexNum as int . 
	Declare variable pointNum as int . 
	Declare variable buffer as short . 
	Declare variable texCoordBuffer as short . 
	Declare variable elementBuffer as short . 
	Declare variable texture as short . 
	Declare variable modelMat as Matrix4x4 . 
	Declare variable transMat as Matrix4x4 . 
	Declare variable scaleMat as Matrix4x4 . 
	Declare variable rotateMat as Matrix4x4 . 
	Declare variable zIndex as double . 
	Declare variable shaderID as int . 
	Declare variable objectColorUniLoc as short . 
	Declare variable transparencyUniLoc as short . 
	Declare variable projMatUniformLoc as short . 
	Declare variable modelMatUniformLoc as short . 
	Declare variable samplerUniformLoc as short . 
	Declare variable animations as Array < AnimationInfo > . 
ending here 
Declare class ${"ja":"シーン2D", "natja":"シーン2D", "en":"Scene2D", "naten":"Scene2D"}$ with members starting here
public : 	Declare variable ${"ja":"スプライト配列", "natja":"スプライト配列", "en":"sprites", "naten":"sprites"}$ as Array < pointer of Sprite > . 
	Declare variable ${"ja":"背景色", "natja":"背景色", "en":"backgroundColor", "naten":"backgroundColor"}$ as Vector3D . 
	Declare variable ${"ja":"背景透明度", "natja":"背景透明度", "en":"backgroundTransparency", "naten":"backgroundTransparency"}$ as double . 
	Declare function Scene2D that takes 高さ as double , color as Vector3D with code starting here
		Assign getTime ( )  / 1000.0 to last . 
		Assign 0.0 to now . 
		Assign 0.0 to elapsedTime . 
		Call identity of projMat . 
		Assign perspectiveMat2D ( projMat , 0  - 高さ  / 2.0  * 16.0  / 9.0 , 高さ  / 2.0  * 16.0  / 9.0 , 0  - 高さ  / 2 , 高さ  / 2 , 0  - 5.0 , 5.0 ) to projMat . 
		Call Array of sprites . 
		Assign color to backgroundColor . 
		Assign 1.0 to backgroundTransparency . 
	ending here 
	Declare function ${"ja":"背景透明度設定", "natja":"背景透明度設定", "en":"setBackgroundTransparency", "naten":"setBackgroundTransparency"}$ that takes a as double with code starting here
		Assign a to backgroundTransparency . 
	ending here 
	Declare function ${"ja":"描画", "natja":"描画", "en":"draw", "naten":"draw"}$ with code starting here
		Assign getTime ( )  / 1000.0 to now . 
		Assign now  - last to elapsedTime . 
		Assign now to last . 
		Call glClearColor with value x of backgroundColor , y of backgroundColor , z of backgroundColor , backgroundTransparency . 
		Call glClearDepth with value 1.0 . 
		Call glEnable with value 2929 . 
		Call glDepthFunc with value 515 . 
		Call glEnable with value 3042 . 
		Call glBlendFunc with value 770 , 771 . 
		Call glClear with value 16640 . 
		( Initialize variable i as int with 0 . ) from ( i  is size of sprites ) to ( Assign i  + 1 to i . ) starting here
			Call get of sprites ( i ) -> draw with value projMat . 
		ending here 
	ending here 
	Declare function ${"ja":"正方形追加", "natja":"正方形追加", "en":"addSquare", "naten":"addSquare"}$ that takes size as double , pos as Vector2D , color as Vector3D , zIndex as double and returns id as int with code starting here
		Initialize variable element 3 in element 4 in vertices as double with [ [ size  / 2 , size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ size  / 2 , 0  - size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - size  / 2 , 0  - size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - size  / 2 , size  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] . 
		Initialize variable element 2 in element 4 in texCoords as double with [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] . 
		Initialize variable element 6 in indices as short with [ 0 , 1 , 3 , 1 , 2 , 3 ] . 
		Initialize variable sprite as pointer of Sprite with allocMemory ( sizeof ( variable at sprite ) ) . 
		Call sprite -> Sprite with value & vertices , 4 , & indices , 6 , color , pos , 4 , zIndex . 
		Call push of sprites with value sprite . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"スプライト追加", "natja":"スプライト追加", "en":"addSprite", "naten":"addSprite"}$ that takes width as double , height as double , pos as Vector2D , url as string , zIndex as double and returns id as int with code starting here
		Initialize variable element 3 in element 4 in vertices as double with [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] . 
		Initialize variable element 2 in element 4 in texCoords as double with [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] . 
		Initialize variable element 6 in indices as short with [ 0 , 1 , 3 , 1 , 2 , 3 ] . 
		Initialize object color as Vector3D with 0.0 , 0.0 , 0.0 . 
		Initialize variable sprite as pointer of Sprite with allocMemory ( sizeof ( variable at sprite ) ) . 
		Call sprite -> Sprite with value & vertices , 4 , & indices , 6 , color , pos , 3 , zIndex . 
		Call sprite -> setTexture with value & texCoords , url . 
		Call push of sprites with value sprite . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"リピートスプライト追加", "natja":"リピートスプライト追加", "en":"addRepeatSprite", "naten":"addRepeatSprite"}$ that takes width as double , height as double , pos as Vector2D , texture as short , zIndex as double and returns id as int with code starting here
		Initialize variable element 3 in element 4 in vertices as double with [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] . 
		Initialize variable element 2 in element 4 in texCoords as double with [ [ 1.0 , 0.0 ] , [ 1.0 , 1.0 ] , [ 0.0 , 1.0 ] , [ 0.0 , 0.0 ] ] . 
		Initialize variable element 6 in indices as short with [ 0 , 1 , 3 , 1 , 2 , 3 ] . 
		Initialize object color as Vector3D with 0.0 , 0.0 , 0.0 . 
		Initialize variable sprite as pointer of Sprite with allocMemory ( sizeof ( variable at sprite ) ) . 
		Call sprite -> Sprite with value & vertices , 4 , & indices , 6 , color , pos , 3 , zIndex . 
		Call sprite -> setRepeatTexture with value & texCoords , texture . 
		Call push of sprites with value sprite . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"四角形追加", "natja":"四角形追加", "en":"addRectangle", "naten":"addRectangle"}$ that takes width as double , height as double , pos as Vector2D , color as Vector3D , zIndex as double and returns id as int with code starting here
		Initialize variable element 3 in element 4 in vertices as double with [ [ width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] , [ 0  - width  / 2 , 0  - height  / 2 , 0  - zIndex  * 0.00100000000000000002 ] ] . 
		Initialize variable sprite as pointer of Sprite with allocMemory ( sizeof ( variable at sprite ) ) . 
		Call sprite -> Sprite with value & vertices , 4 , allocMemory ( 0 ) , 0 , color , pos , 4 , zIndex . 
		Call push of sprites with value sprite . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"多角形追加", "natja":"多角形追加", "en":"addPolygon", "naten":"addPolygon"}$ that takes points as pointer of void , size as int , pos as Vector2D , color as Vector3D , zIndex as double and returns id as int with code starting here
		Initialize variable sprite as pointer of Sprite with allocMemory ( sizeof ( variable at sprite ) ) . 
		Call sprite -> Sprite with value points , size , allocMemory ( 0 ) , 0 , color , pos , 4 , zIndex . 
		Call push of sprites with value sprite . 
		Assign length of sprites ( )  - 1 to id . 
	ending here 
	Declare function ${"ja":"円追加", "natja":"円追加", "en":"addCircle", "naten":"addCircle"}$ that takes r as double , pos as Vector2D , color as Vector3D , zIndex as double and returns id as int with code starting here
		Initialize variable PI as double with 3.14159265358979312 . 
		Initialize object points as Array < Vector3D > with . 
		Initialize variable 頂点数 as int with 60 . 
		( Initialize variable i as int with 0 . ) from ( i  is 頂点数 ) to ( Assign i  + 1 to i . ) starting here
			Initialize variable theta as double with 0 . 
			If ( i  % 2 )  is 0 then execute code starting here
				Assign 0.5  * PI  + ( ( PI  * i )  / 頂点数 ) to theta . 
			ending here 
			If ( i  % 2 )  is 1 then execute code starting here
				Assign 0.5  * PI  - ( ( PI  * ( 1.0  + i ) )  / 頂点数 ) to theta . 
			ending here 
			Initialize object temp as Vector3D with r  * cos ( theta ) , r  * sin ( theta ) , 0  - zIndex  * 0.00100000000000000002 . 
			Call push of points with value temp . 
		ending here 
		Assign addPolygon ( content of points , size of points , pos , color , zIndex ) to id . 
	ending here 
private : 	Declare variable projMat as Matrix4x4 . 
	Declare variable last as double . 
	Declare variable now as double . 
	Declare variable elapsedTime as double . 
ending here 
Declare function 引数なしjsリスナー呼び出し that takes callback as function : ( ) => ( ) with code starting here
	Call callback . 
ending here 
Export function 引数なしjsリスナー呼び出し to "jsCallListenerNoParam". 
Declare function main with code starting here
	Call captureMouse . 
	Initialize object ワールド as Scene with . 
	Initialize object 光源座標 as Vector3D with 5.0 , 5.0 , 5.0 . 
	Initialize object 回転軸 as Vector3D with 0.0 , 1.0 , 0.0 . 
	Initialize object color as Vector3D with 0.900000000000000022 , 0.5 , 0.699999999999999956 . 
	Initialize object 位置 as Vector3D with 0.0 , 0.0 , 0.0 . 
	Initialize variable キューブID as int with addCube of ワールド ( 2.0 , color , 位置 ) . 
	Initialize variable 光源ID as int with addLight of ワールド ( 1.0 , color , 光源座標 ) . 
	Declare function loop with code starting here
		Call get of sprites of ワールド ( キューブID ) -> rotate with value 回転軸 , getTime ( )  / 1000.0 . 
		Call draw of ワールド . 
	ending here 
ending here 
