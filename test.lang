関数:表示(実数:x)=>()=js読み込み("console", "log");
関数:行列表示(実数:offset[4][4])=>()=js読み込み("console", "logMatrix");
関数:アドレス表示(*無:x)=>()=js読み込み("console", "log");
関数:_文字列表示(*文字:x, 整数:長さ)=>()=js読み込み("console", "logstring");
関数:時間計測()=>(実数:時間)=js読み込み("performance", "now");
関数:glClearDepth(整数32:i)=>()=js読み込み("webgl", "clearDepth");
関数:glDepthFunc(整数32:i)=>()=js読み込み("webgl", "depthFunc");
関数:glEnable(整数32:i)=>()=js読み込み("webgl", "enable");
関数:glDisable(整数32:i)=>()=js読み込み("webgl", "disable");
関数:glCreateProgram()=>(整数32:prog)=js読み込み("webgl", "createProgram");
関数:glCreateBuffer()=>(整数32:buffer)=js読み込み("webgl", "createBuffer");
関数:glBindBuffer(整数32:i, 整数32:j)=>()=js読み込み("webgl", "bindBuffer");
関数:glBufferData(整数32:i, *実数:offset, 整数32:size, 整数32:j)=>()=js読み込み("webgl", "bufferData");
関数:glElementBufferData(整数32:i, *整数32:offset, 整数32:size, 整数32:j)=>()=js読み込み("webgl", "elementBufferData");
関数:glUseProgram(整数32:i)=>()=js読み込み("webgl", "useProgram");
関数:glGetAttribLocation(整数32:i, *文字:offset, 整数32:size)=>(整数32:loc)=js読み込み("webgl", "getAttribLocation");
関数:glVertexAttribPointer(整数32:index, 整数32:size, 整数32:type, 整数32:normalized, 整数32:stride, 整数32:offset)=>()=js読み込み("webgl", "vertexAttribPointer");
関数:glEnableVertexAttribArray(整数32:index)=>()=js読み込み("webgl", "enableVertexAttribArray");
関数:glDrawArrays(整数32:i, 整数32:first, 整数32:count)=>()=js読み込み("webgl", "drawArrays");
関数:_glGetUniformLocation(整数32:i, *文字:offset, 整数32:size)=>(整数32:loc)=js読み込み("webgl", "getUniformLocation");
関数:glUniformMatrix2fv(整数32:loc, 整数32:trans, *実数:offset)=>()=js読み込み("webgl", "uniformMatrix2fv");
関数:glUniformMatrix3fv(整数32:loc, 整数32:trans, *実数:offset)=>()=js読み込み("webgl", "uniformMatrix3fv");
関数:glUniformMatrix4fv(整数32:loc, 整数32:trans, 実数:offset[16])=>()=js読み込み("webgl", "uniformMatrix4fv");
関数:glUniform1f(整数32:loc, 実数: v0)=>()=js読み込み("webgl", "uniform1f");
関数:glUniform1fv(整数32:loc, 実数: v0)=>()=js読み込み("webgl", "uniform1fv");
関数:glUniform1i(整数32:loc, 整数32: v0)=>()=js読み込み("webgl", "uniform1i");
関数:glUniform1iv(整数32:loc, 整数32: v0)=>()=js読み込み("webgl", "uniform1iv");
関数:glUniform2f(整数32:loc, 実数: v0, 実数: v1)=>()=js読み込み("webgl", "uniform2f");
関数:glUniform2fv(整数32:loc, 実数: v0, 実数: v1)=>()=js読み込み("webgl", "uniform2fv");
関数:glUniform2i(整数32:loc, 整数32: v0, 整数32: v1)=>()=js読み込み("webgl", "uniform2i");
関数:glUniform2iv(整数32:loc, 整数32: v0, 整数32: v1)=>()=js読み込み("webgl", "uniform2iv");
関数:glUniform3f(整数32:loc, 実数: v0, 実数: v1, 実数: v2)=>()=js読み込み("webgl", "uniform3f");
関数:glUniform3fv(整数32:loc, 実数: v0, 実数: v1, 実数: v2)=>()=js読み込み("webgl", "uniform3fv");
関数:glUniform3i(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2)=>()=js読み込み("webgl", "uniform3i");
関数:glUniform3iv(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2)=>()=js読み込み("webgl", "uniform3iv");
関数:glUniform4f(整数32:loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3)=>()=js読み込み("webgl", "uniform4f");
関数:glUniform4fv(整数32:loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3)=>()=js読み込み("webgl", "uniform4fv");
関数:glUniform4i(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3)=>()=js読み込み("webgl", "uniform4i");
関数:glUniform4iv(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3)=>()=js読み込み("webgl", "uniform4iv");
関数:glClearColor(実数:r, 実数:g, 実数:b, 実数:a)=>()=js読み込み("webgl", "clearColor");
関数:glClear(整数32:color)=>()=js読み込み("webgl", "clear");
関数:glDrawElements(整数32:i, 整数32:count, 整数32:type, 整数32:offset)=>()=js読み込み("webgl", "drawElements");
関数:glBlendFunc(整数32:i, 整数32:j)=>()=js読み込み("webgl", "blendFunc");
関数:キーチェック(整数32:keyCode)=>(整数:pressed)=js読み込み("js", "checkKeyPress");
関数:マウスチェック()=>(整数:pressed)=js読み込み("js", "checkMousePress");
関数:マウス相対座標X()=>(実数:x)=js読み込み("js", "checkRelativeMouseX");
関数:マウス相対座標Y()=>(実数:x)=js読み込み("js", "checkRelativeMouseY");
関数:マウス絶対座標X()=>(実数:x)=js読み込み("js", "checkAbsoluteMouseX");
関数:マウス絶対座標Y()=>(実数:x)=js読み込み("js", "checkAbsoluteMouseY");
関数:jsRand()=>(実数:x)=js読み込み("js", "rand");
関数:メモリ確保(整数32:size)=>(*無:p)=js読み込み("js", "alloc");
関数:_loadTexture(*文字:offset, 整数32:length)=>(整数32:a)=js読み込み("webgl", "loadTexture");
関数:glActiveTexture(整数32:i)=>()=js読み込み("webgl", "activeTexture");
関数:glBindTexture(整数32:i, 整数32:j)=>()=js読み込み("webgl", "bindTexture");
関数:クリックしたら消える() => () = js読み込み("js", "lockPointer");
関数:sin(実数:input)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 整数:temp=input/(2.0*PI);
 実数:rad=input-(2.0*PI*temp);
 実数:plusminus = 1.0;
 もし(rad < 0.0)ならば{
	 rad = rad + (2.0 * PI);
 }
 もし(rad>PI)ならば
 {
	 plusminus = -1.0;
	もし(rad > 1.5 * PI)ならば{
		rad = (2.0 * PI) - rad;
	}
	でなければ{
		rad = rad - PI;
	}
 }
 でなければ{
	 もし(rad > 0.5 * PI)ならば{
		 rad = PI - rad;
	 }
 }
 もし(rad > 0.25 * PI)ならば{
	 rad = (0.5 * PI) - rad;
	 	実数:doubleRad=rad*rad;
 		結果=1.0-(doubleRad)/2.0+(doubleRad*doubleRad)/24.0-(doubleRad*doubleRad*doubleRad)/720.0+(doubleRad*doubleRad*doubleRad*doubleRad)/40320.0
 		 -(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/3628800.0+(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/479001600.0;
		結果 = 結果 * plusminus;
 }
 でなければ{
		実数:doubleRad=rad*rad;
		結果=rad-(rad*doubleRad)/6.0+(rad*doubleRad*doubleRad)/120.0-(rad*doubleRad*doubleRad*doubleRad)/5040.0
		 +(rad*doubleRad*doubleRad*doubleRad*doubleRad)/362880.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/39916800.0
		 +(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/6227020800.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/1307674368000.0;
		結果= 結果 * plusminus;
	}
}

関数:cos(実数:input)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 整数:temp=input/(2*PI);
 実数:rad=input-(2*PI*temp);
 実数:plusminus = 1.0;
 もし(rad < 0.0)ならば{
	 rad = rad + (2.0 * PI);
 }
 もし(rad>PI)ならば
 {
	もし(rad > 1.5 * PI)ならば{
		rad = (2.0 * PI) - rad;
	}
	でなければ{
	 	plusminus = -1.0;
		rad = rad - PI;
	}
 }
 でなければ{
	 もし(rad > 0.5 * PI)ならば{
		 plusminus = -1.0;
		 rad = PI - rad;
	 }
 }
 もし(rad < 0.25 * PI)ならば{
	 	実数:doubleRad=rad*rad;
 		結果=1.0-(doubleRad)/2.0+(doubleRad*doubleRad)/24.0-(doubleRad*doubleRad*doubleRad)/720.0+(doubleRad*doubleRad*doubleRad*doubleRad)/40320.0
 		 -(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/3628800.0+(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/479001600.0;
		結果 = 結果 * plusminus;
 }
 でなければ{
	 	 rad = (0.5 * PI) - rad;

		実数:doubleRad=rad*rad;
		結果=rad-(rad*doubleRad)/6.0+(rad*doubleRad*doubleRad)/120.0-(rad*doubleRad*doubleRad*doubleRad)/5040.0
		 +(rad*doubleRad*doubleRad*doubleRad*doubleRad)/362880.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/39916800.0
		 +(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/6227020800.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/1307674368000.0;
		結果= 結果 * plusminus;
	}
}

関数:tan(実数:rad)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 実数:sqRad=rad*rad;
    結果=sin(rad)/cos(rad);
}

型<T>:関数:abs(T:a) => (T:b)
{
 もし(a >= 0)ならば{
  b = a;
 }
 でなければ{
  b = -a;
 }
}

関数:toRad(実数:deg)=>(実数:rad)
{
 実数:PI=3.14159265358979323846264338;
 rad = (deg/180) * PI;
}

関数:root(実数:x)=>(実数:y)
{
 y=5;
 (整数:i=0;)から(i==20)まで(i++;)
 {
  y=0.5*(y+(x/y));
 }
}

関数:length3d(実数:x, 実数:y, 実数:z)=>(実数:length)
{
 length = root(x*x+y*y+z*z);
}

関数:normalize(実数:vector[3])=>()
{
 実数:length = length3d(vector[0], vector[1], vector[2]);
 もし(length==0.0)ならば
 {
  終了;
 }
 vector[0]=vector[0]/length;
 vector[1]=vector[1]/length;
 vector[2]=vector[2]/length;
}

関数:dot(実数:vec1[3], 実数:vec2[3])=>(実数:結果)
{
 結果=vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];
}

関数:cross(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[1]*vec2[2]-vec1[2]*vec2[1];
 output[1]=vec1[2]*vec2[0]-vec1[0]*vec2[2];
 output[2]=vec1[0]*vec2[1]-vec1[1]*vec2[0];
}

関数:vecMultiply(実数:output[3], 実数:vec[3], 実数:x)=>()
{
 output[0]=vec[0]*x;
 output[1]=vec[1]*x;
 output[2]=vec[2]*x;
}

関数:vecSub(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[0]-vec2[0];
 output[1]=vec1[1]-vec2[1];
 output[2]=vec1[2]-vec2[2];
}

関数:vecAdd(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[0]+vec2[0];
 output[1]=vec1[1]+vec2[1];
 output[2]=vec1[2]+vec2[2];
}
型<T>:クラス:配列
{
    *T:content;
    整数:size;
    関数:配列()=>()
    {
        size = 0;
        allocated = 2;
        //表示(バイト数(*content));
        content=メモリ確保(バイト数(*content) * allocated);
    }
    関数:取得(整数:index)=>(T:result)
    {
        終了(content[index]);
    }
    関数:追加(T:new)=>()
    {
        もし(size == allocated)ならば
        {
            allocated = allocated * 2;
            *T:temp = content;
            content = メモリ確保(バイト数( *content)*allocated);
            (整数:i=0;)から(i==allocated)まで(i++;)
            {
                content[i]=temp[i];
            }
        }
        content[size]=new;
        size++;
    }
    関数:長さ()=>(整数:a)
    {
        a = size;
    }
    関数:ポップ() => (){
        size--;
    }
    非公開:
        整数:allocated;
}

クラス:文字列
{
    *文字:content;
    整数:length;
    関数:文字列(*文字:offset, 整数:l)=>()
    {
        content = offset;
        length = l;
    }
    関数:代入(*文字:offset, 整数:l)=>()
    {
        content = offset;
        length = l;
    }
}
関数:文字列表示(文字列:a)=>()
{
    _文字列表示(a.content, a.length);
}
関数:glGetUniformLocation(整数32:i, 文字列:a)=>(整数32:loc)
{
    loc = _glGetUniformLocation(i, a.content, a.length);
}
クラス:ベクトル3D
{
    実数:x;
    実数:y;
    実数:z;
    関数:ベクトル3D(実数:a, 実数:b, 実数:c)=>()
    {
        x = a;
        y = b;
        z = c;
    }
    関数:長さ()=>(実数:l)
    {
        l = root(x*x+y*y+z*z);
    }
    関数:正規化()=>()
    {
        実数:l=root((x*x)+(y*y)+(z*z));
        x = x / l;
        y = y / l;
        z = z / l;
    }
}
関数:ベクトル3Dの和(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x = a.x + b.x;
    result.y = a.y + b.y;
    result.z = a.z + b.z;
}
関数:ベクトル3Dの差(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x = a.x - b.x;
    result.y = a.y - b.y;
    result.z = a.z - b.z;
}

関数:ベクトル3Dの内積(ベクトル3D:a, ベクトル3D:b)=>(実数:x)
{
    x = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}

関数:ベクトル3Dの外積(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x= (a.y * b.z) - (a.z * b.y);
 result.y= (a.z * b.x) - (a.x * b.z);
 result.z= (a.x * b.y) - (a.y * b.x);
}

関数:ベクトル3D拡大(ベクトル3D:a, 実数:x)=>(ベクトル3D:result)
{
    result.x = a.x * x;
    result.y = a.y * x;
    result.z = a.z * x;
}

関数:ベクトル3D縮小(ベクトル3D:a, 実数:x)=>(ベクトル3D:result)
{
    もし(x == 0.0)ならば{
        表示(10000000);
    }
    result.x = a.x / x;
    result.y = a.y / x;
    result.z = a.z / x;
}
クラス:行列4x4
{
    実数:matrix[16];
    関数:行列4x4()=>()
    {
        matrix =
        [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ];
    }
    関数:初期化()=>()
    {
        matrix =
        [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ];
    }
    関数:移動(ベクトル3D:offset)=>()
    {
        実数:mat12=matrix[12];
        実数:mat13=matrix[13];
        実数:mat14=matrix[14];
        実数:mat15=matrix[15];
        matrix[12] = matrix[0] * offset.x + matrix[4] * offset.y + matrix[8] * offset.z + mat12;
        matrix[13] = matrix[1] * offset.x + matrix[5] * offset.y + matrix[9] * offset.z + mat13;
        matrix[14] = matrix[2] * offset.x + matrix[6] * offset.y + matrix[10] * offset.z + mat13;
        matrix[15] = matrix[3] * offset.x + matrix[7] * offset.y + matrix[11] * offset.z + mat15;
    }
    関数:回転(ベクトル3D:axis, 実数:theta)=>()
    {
        axis.正規化();
        実数:s=sin(theta);
        実数:c=cos(theta);
        実数:t=1.0-c;

        実数:a00=matrix[0];
        実数:a01=matrix[1];
        実数:a02=matrix[2];
        実数:a03=matrix[3];
        実数:a10=matrix[4];
        実数:a11=matrix[5];
        実数:a12=matrix[6];
        実数:a13=matrix[7];
        実数:a20=matrix[8];
        実数:a21=matrix[9];
        実数:a22=matrix[10];
        実数:a23=matrix[11];

        実数:b00=axis.x * axis.x * t + c;
        実数:b01=axis.y * axis.x * t + axis.z * s;
        実数:b02=axis.z * axis.x * t - axis.y * s;
        実数:b10=axis.x * axis.y * t - axis.z * s;
        実数:b11=axis.y * axis.y * t + c;
        実数:b12=axis.z * axis.y * t + axis.x * s;
        実数:b20=axis.x * axis.z * t + axis.y * s;
        実数:b21=axis.y * axis.z * t - axis.x * s;
        実数:b22=axis.z * axis.z * t + c;

        matrix[0]=a00 * b00 + a10 * b01 + a20 * b02;
        matrix[1]=a01 * b00 + a11 * b01 + a21 * b02;
        matrix[2]=a02 * b00 + a12 * b01 + a22 * b02;
        matrix[3]=a03 * b00 + a13 * b01 + a23 * b02;
        matrix[4]=a00 * b10 + a10 * b11 + a20 * b12;
        matrix[5]=a01 * b10 + a11 * b11 + a21 * b12;
        matrix[6]=a02 * b10 + a12 * b11 + a22 * b12;
        matrix[7]=a03 * b10 + a13 * b11 + a23 * b12;
        matrix[8]=a00 * b20 + a10 * b21 + a20 * b22;
        matrix[9]=a01 * b20 + a11 * b21 + a21 * b22;
        matrix[10]=a02 * b20 + a12 * b21 + a22 * b22;
        matrix[11]=a03 * b20 + a13 * b21 + a23 * b22;
    }
    関数:拡大縮小(実数:x, 実数:y, 実数:z)=>()
    {
        matrix[0]= matrix[0]*x;
        matrix[1]= matrix[1]*x;
        matrix[2]= matrix[2]*x;
        matrix[3]= matrix[3]*x;
        matrix[4]= matrix[4]*y;
        matrix[5]= matrix[5]*y;
        matrix[6]= matrix[6]*y;
        matrix[7]= matrix[7]*y;
        matrix[8]= matrix[8]*z;
        matrix[9]= matrix[9]*z;
        matrix[10]=matrix[10]*z;
        matrix[11]=matrix[11]*z;
    }
}

関数:カメラ行列(行列4x4:m, ベクトル3D:pos, ベクトル3D:lookAt, ベクトル3D:up)=>(行列4x4:res)
{
    ベクトル3D:newForward(lookAt.x - pos.x, lookAt.y - pos.y, lookAt.z - pos.z);
    ベクトル3D:a(0.0, 0.0, 0.0);
    a = ベクトル3D拡大(newForward, ベクトル3Dの内積(up, newForward));
    ベクトル3D:newUp(up.x - a.x, up.y - a.y, up.z - a.z);
    newUp.正規化();

    ベクトル3D:newRight(0, 0, 0);
    newRight = ベクトル3Dの外積(newUp, newForward);

    m.matrix =
    [
        newRight.x, newUp.x, newForward.x, 0.0,
        newRight.y, newUp.y, newForward.y, 0.0,
        newRight.z, newUp.z, newForward.z, 0.0,
        -ベクトル3Dの内積(newRight, pos), -ベクトル3Dの内積(newUp, pos), -ベクトル3Dの内積(newForward, pos), 1.0
    ];
    終了(m);
}

関数:視点行列3D(行列4x4:m, 実数:fov, 実数:width, 実数:height, 実数:zN, 実数:zF)=>(行列4x4:result)
{
 実数:PI=3.141592653589793;
    実数:fov=1.0 / tan((90.0/360.0)*PI);
 実数:aspectRatio=width/height;
 実数:zNear=zN;
 実数:zFar= zF;
 実数:zQ=zF/(zF-zN);
    m.matrix =
    [
        aspectRatio*fov, 0.0, 0.0, 0.0,
        0.0, fov, 0.0, 0.0,
        0.0, 0.0, zQ, 1.0,
        0.0, 0.0, (-zFar * zNear)/(zFar - zNear), 0.0
    ];
    終了(m);
}

関数:視点行列2D(行列4x4:m, 実数:left, 実数:right, 実数:bottom, 実数:top, 実数:near, 実数:far)=>(行列4x4:result)
{
    m.matrix =
    [
        2.0/(right - left), 0.0, 0.0, 0.0,
        0.0, 2.0/(top - bottom), 0.0, 0.0,
        0.0, 0.0, -2.0/(near - far), 0.0,
        -(right + left)/(right - left), -(top + bottom)/(top - bottom), -(far + near)/(far - near), 1.0
    ];
    終了(m);
}

関数:行列4x4の積(行列4x4:a, 行列4x4:b)=>(行列4x4:out)
{
    out.matrix[0] = b.matrix[0] * a.matrix[0] + b.matrix[1] * a.matrix[4] + b.matrix[2] * a.matrix[8] + b.matrix[3] * a.matrix[12];
    out.matrix[1] = b.matrix[0] * a.matrix[1] + b.matrix[1] * a.matrix[5] + b.matrix[2] * a.matrix[9] + b.matrix[3] * a.matrix[13];
    out.matrix[2] = b.matrix[0] * a.matrix[2] + b.matrix[1] * a.matrix[6] + b.matrix[2] * a.matrix[10] + b.matrix[3] * a.matrix[14];
    out.matrix[3] = b.matrix[0] * a.matrix[3] + b.matrix[1] * a.matrix[7] + b.matrix[2] * a.matrix[11] + b.matrix[3] * a.matrix[15];
    out.matrix[4] = b.matrix[4] * a.matrix[0] + b.matrix[5] * a.matrix[4] + b.matrix[6] * a.matrix[8] + b.matrix[7] * a.matrix[12];
    out.matrix[5] = b.matrix[4] * a.matrix[1] + b.matrix[5] * a.matrix[5] + b.matrix[6] * a.matrix[9] + b.matrix[7] * a.matrix[13];
    out.matrix[6] = b.matrix[4] * a.matrix[2] + b.matrix[5] * a.matrix[6] + b.matrix[6] * a.matrix[10] + b.matrix[7] * a.matrix[14];
    out.matrix[7] = b.matrix[4] * a.matrix[3] + b.matrix[5] * a.matrix[7] + b.matrix[6] * a.matrix[11] + b.matrix[7] * a.matrix[15];
    out.matrix[8] = b.matrix[8] * a.matrix[0] + b.matrix[9] * a.matrix[4] + b.matrix[10] * a.matrix[8] + b.matrix[11] * a.matrix[12];
    out.matrix[9] = b.matrix[8] * a.matrix[1] + b.matrix[9] * a.matrix[5] + b.matrix[10] * a.matrix[9] + b.matrix[11] * a.matrix[13];
    out.matrix[10] = b.matrix[8] * a.matrix[2] + b.matrix[9] * a.matrix[6] + b.matrix[10] * a.matrix[10] + b.matrix[11] * a.matrix[14];
    out.matrix[11] = b.matrix[8] * a.matrix[3] + b.matrix[9] * a.matrix[7] + b.matrix[10] * a.matrix[11] + b.matrix[11] * a.matrix[15];
    out.matrix[12] = b.matrix[12] * a.matrix[0] + b.matrix[13] * a.matrix[4] + b.matrix[14] * a.matrix[8] + b.matrix[15] * a.matrix[12];
    out.matrix[13] = b.matrix[12] * a.matrix[1] + b.matrix[13] * a.matrix[5] + b.matrix[14] * a.matrix[9] + b.matrix[15] * a.matrix[13];
    out.matrix[14] = b.matrix[12] * a.matrix[2] + b.matrix[13] * a.matrix[6] + b.matrix[14] * a.matrix[10] + b.matrix[15] * a.matrix[14];
    out.matrix[15] = b.matrix[12] * a.matrix[3] + b.matrix[13] * a.matrix[7] + b.matrix[14] * a.matrix[11] + b.matrix[15] * a.matrix[15];
}
クラス:モデル
{
    ベクトル3D:color;
    ベクトル3D:pos;

    関数:モデル(*実数:data, 整数:num, ベクトル3D:c, ベクトル3D:p, 整数:s)=>()
    {
        vertices = data;
        vertexNum = num;
        color = c;
        pos = p;
        shaderID = s;

        modelMat.初期化();
        transMat.初期化();
        scaleMat.初期化();
        rotateMat.初期化();

        文字:_lightPosUniform[8]="lightPos";
     文字:_viewPosUniform[8]="viewPos";
     文字:_lightColorUniform[10]="lightColor";
     文字:_objectColorUniform[11]="objectColor";
     文字:_projUniform[8]="uProjMat";
     文字:_viewUniform[8]="uViewMat";
     文字:_modelUniform[9]="uModelMat";

     文字列:lightPosUniform(&_lightPosUniform, 8);
     文字列:viewPosUniform(&_viewPosUniform, 7);
     文字列:lightColorUniform(&_lightColorUniform, 10);
     文字列:objectColorUniform(&_objectColorUniform, 11);
     文字列:projUniform(&_projUniform, 8);
     文字列:viewUniform(&_viewUniform, 8);
     文字列:modelUniform(&_modelUniform, 9);

        もし(shaderID == 0)ならば
        {
            viewPosUniLoc=glGetUniformLocation(0, viewPosUniform);
         lightPosUniLoc=glGetUniformLocation(0, lightPosUniform);
         lightColorUniLoc=glGetUniformLocation(0, lightColorUniform);
         objectColorUniLoc=glGetUniformLocation(0, objectColorUniform);
        }

        projMatUniformLoc=glGetUniformLocation(shaderID, projUniform);
     viewMatUniformLoc=glGetUniformLocation(shaderID, viewUniform);
     modelMatUniformLoc=glGetUniformLocation(shaderID, modelUniform);
        //アドレス表示(data);
        buffer = glCreateBuffer();
        glBindBuffer(0x8892, buffer);
        glBufferData(0x8892, vertices, num * 6, 0x88E4);
    }
    関数:座標設定(ベクトル3D:coord)=>()
    {
        pos = coord;
    }
    関数:移動(ベクトル3D:offset)=>()
    {
        pos = ベクトル3Dの和(pos, offset);
    }
    関数:拡大縮小(実数:x, 実数:y, 実数:z)=>()
    {
        行列4x4:temp();
        temp.初期化();
        temp.拡大縮小(x, y, z);
        scaleMat = 行列4x4の積(temp, scaleMat);
    }
    関数:回転(ベクトル3D:axis, 実数:t)=>()
    {
        行列4x4:temp();
        temp.初期化();
        temp.回転(axis, t);
        rotateMat = 行列4x4の積(temp, rotateMat);
    }
    関数:描画(行列4x4:projMat, 行列4x4:viewMat, ベクトル3D:camera)=>()
    {
     実数:PI=3.14159265358979323846264338;
        transMat.移動(pos);
        modelMat.初期化();

        modelMat = 行列4x4の積(scaleMat, modelMat);
        modelMat = 行列4x4の積(rotateMat, modelMat);
        modelMat = 行列4x4の積(transMat, modelMat);
        glBindBuffer(0x8892, buffer);
        glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, 3, 0x1406, 0, 6 * 4, 0);
  glEnableVertexAttribArray(1);
  glVertexAttribPointer(1, 3, 0x1406, 0, 6 * 4, 3 * 4);
        glUseProgram(shaderID);
        もし(shaderID == 0)ならば{
      glUniform3f(lightPosUniLoc, 5.0, 5.0, 5.0);
      glUniform3f(lightColorUniLoc, 1.0, 1.0, 1.0);
      glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
      glUniform3f(viewPosUniLoc, camera.x, camera.y, camera.z);
        }
  glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
  glUniformMatrix4fv(viewMatUniformLoc, 0, viewMat.matrix);
  glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
        glDrawArrays(0x0004, 0, 36);
        rotateMat.初期化();
        transMat.初期化();
        scaleMat.初期化();
    }

    非公開:
        *実数:vertices;
        整数:vertexNum;
        整数32:buffer;
        行列4x4:modelMat;
        行列4x4:transMat;
        行列4x4:scaleMat;
        行列4x4:rotateMat;
        整数:shaderID;
        整数32:viewPosUniLoc;
        整数32:lightPosUniLoc;
        整数32:lightColorUniLoc;
        整数32:objectColorUniLoc;
        整数32:projMatUniformLoc;
        整数32:viewMatUniformLoc;
        整数32:modelMatUniformLoc;
}
クラス:カメラ
{
    ベクトル3D:座標;
    実数:感度;
    関数:カメラ(ベクトル3D:p)=>()
    {
        座標 = p;
        view.ベクトル3D(0.0, 0.0, 1.0);
        lookDir.ベクトル3D(0.0, 0.0, 1.0);
        up.ベクトル3D(0.0, 1.0, 0.0);
        yaw = 90.0;
        pitch = 0.0;
        感度 = 0.1;
    }
    関数:感度設定(実数:s)=>()
    {
        感度 = s;
    }
    関数:アップデート(実数:xOffset, 実数:yOffset, 実数:elapsedTime)=>(行列4x4:result)
    {
        もし(キーチェック(32) == 1)ならば{
   座標.y+=elapsedTime*5.0;
  }
  もし(キーチェック(16) == 1)ならば{
   座標.y-=elapsedTime*5.0;
  }
  もし(キーチェック(65)==1)ならば{
   座標.z-=elapsedTime * sin(toRad(yaw-90))*5.0;
   座標.x-=elapsedTime * cos(toRad(yaw-90))*5.0;
  }
  もし(キーチェック(68)==1)ならば{
   座標.z+=elapsedTime * sin(toRad(yaw-90))*5.0;
   座標.x+=elapsedTime * cos(toRad(yaw-90))*5.0;
  }
  もし(キーチェック(87)==1)ならば{
   座標.z+=elapsedTime * sin(toRad(yaw))*5.0;
   座標.x+=elapsedTime * cos(toRad(yaw))*5.0;
  }
  もし(キーチェック(83)==1)ならば{
   座標.z-=elapsedTime * sin(toRad(yaw))*5.0;
   座標.x-=elapsedTime * cos(toRad(yaw))*5.0;
  }

        yaw -= xOffset * 感度;
        pitch -= yOffset * 感度;
        もし(pitch < -89.0)ならば
        {
            pitch = -89.0;
        }
        もし(pitch > 89.0)ならば
        {
            pitch = 89.0;
        }
        lookDir.x=cos(toRad(yaw))*cos(toRad(pitch));
  			lookDir.y=sin(toRad(pitch));
  			lookDir.z=sin(toRad(yaw))*cos(toRad(pitch));
				// 表示(sin(toRad(yaw)));
  			lookDir.正規化();

        result.初期化();
        view = ベクトル3Dの和(lookDir, 座標);
        result = カメラ行列(result, 座標, view, up);
    }
    非公開:
        ベクトル3D:view;
        ベクトル3D:lookDir;
        ベクトル3D:up;
        実数:yaw;
        実数:pitch;
}
クラス:シーン
{
    配列<*モデル>:スプライト;
    カメラ:目;
    関数:シーン()=>()
    {
        last = 時間計測()/1000.0;
        now = 0.0;
        elapsedTime = 0.0;
        lastX = マウス絶対座標X();
        lastY = マウス絶対座標Y();
        projMat.初期化();
        viewMat.初期化();
        projMat = 視点行列3D(projMat, 90.0, 720.0, 1280.0, 0.1, 100.0);
        ベクトル3D:temp(0.0, 0.0, -4.0);
        目.カメラ(temp);
        スプライト.配列();
    }
    関数:描画()=>()
    {
        now = 時間計測()/1000.0;
        elapsedTime = now - last;
        last = now;
        glClearColor(0.0, 0.0, 0.0, 1.0);
  glClearDepth(1.0);
  glEnable(0x0B71);
  glDepthFunc(0x0203);
  glClear(16640);

        実数:xOffset=マウス絶対座標X()-lastX;
  実数:yOffset=マウス絶対座標Y()-lastY;
  lastX=マウス絶対座標X();
  lastY=マウス絶対座標Y();
        viewMat.初期化();
        viewMat = 目.アップデート(xOffset, yOffset, elapsedTime);
        (整数:i = 0;)から(i == スプライト.size)まで(i++;)
        {
            スプライト.取得(i) -> 描画(projMat, viewMat, 目.座標);
        }
    }
    関数:キューブ追加(実数:size, ベクトル3D:color, ベクトル3D:pos)=>(整数:id)
    {
        実数:vertices[12][3][6]=
     [
         //south
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [-size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, -size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         //east
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0]
         ],
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0],
             [size/2, -size/2, size/2, 1.0, 0.0, 0.0]
         ],
         //north
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, -size/2, size/2, 0.0, 0.0, 1.0]
         ],
         //west
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0],
             [-size/2, -size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         //top
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [-size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0]
         ],
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, -size/2, 0.0, 1.0, 0.0]
         ],
         //bottom
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0],
             [size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ]
     ];
        *モデル:cube = メモリ確保(バイト数(*cube));
        // アドレス表示(&vertices);
        cube -> モデル(&vertices, 36, color, pos, 0);
        スプライト.追加(cube);
        id = スプライト.長さ() - 1;
    }
    関数:ライト追加(実数:size, ベクトル3D:color, ベクトル3D:pos)=>(整数:id)
    {
        実数:vertices[12][3][6]=
     [
         //south
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [-size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, -size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         //east
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0]
         ],
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0],
             [size/2, -size/2, size/2, 1.0, 0.0, 0.0]
         ],
         //north
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, -size/2, size/2, 0.0, 0.0, 1.0]
         ],
         //west
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0],
             [-size/2, -size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         //top
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [-size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0]
         ],
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, -size/2, 0.0, 1.0, 0.0]
         ],
         //bottom
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0],
             [size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ]
     ];
        *モデル:light = メモリ確保(バイト数(*light));
        light -> モデル(&vertices, 36, color, pos, 1);
        スプライト.追加(light);
        id = スプライト.長さ() - 1;
    }
    非公開:
        行列4x4:projMat;
        行列4x4:viewMat;
        実数:last;
        実数:now;
        実数:elapsedTime;
        実数:lastX;
        実数:lastY;
}
関数:実行 () => () {
	クリックしたら消える();
    シーン:ワールド();
    ベクトル3D:光源座標(5.0, 5.0, 5.0);
    ベクトル3D:回転軸(0.0, 1.0, 0.0);
    ベクトル3D:色(0.2, 0.5, 0.7);
    ベクトル3D:位置(0.0, 0.0, 0.0);

    整数:キューブID = ワールド.キューブ追加(2.0, 色, 位置);
    整数:光源ID = ワールド.ライト追加(1.0, 色, 光源座標);

    無限ループ {
            ワールド.スプライト.取得(キューブID) -> 回転(回転軸, 時間計測()/1000.0);
            ワールド.描画();
    }
}