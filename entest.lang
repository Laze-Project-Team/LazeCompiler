function: 実数表示(real: x) => () = jsload("console", "log");
function: Arduino設定(int: vendorId, function: () => (): c) => () = jsload("arduino", "setUp");
function: Arduinoコマンド送信(char: コマンド, short: data) => () = jsload("arduino", "sendCommand");
function: Arduinoデータ受信() => () = jsload("arduino", "checkInput");
function: Arduinoアナログ入力(int: ピン番号) => (short: データ) = jsload("arduino", "analogRead");
function: Arduinoデジタル入力(int: ピン番号) => (short: データ) = jsload("arduino", "digitalRead");
function: 行列表示(real: offset[4][4]) => () = jsload("console", "logMatrix");
function: アドレス表示(*void: x) => () = jsload("console", "log");
function: _文字列表示(*char: x, int: 長さ) => () = jsload("console", "logstring");
function: 時間計測() => (real: 時間) = jsload("performance", "now");
function: glClearDepth(short: i) => () = jsload("webgl", "clearDepth");
function: glDepthFunc(short: i) => () = jsload("webgl", "depthFunc");
function: glEnable(short: i) => () = jsload("webgl", "enable");
function: glDisable(short: i) => () = jsload("webgl", "disable");
function: glCreateProgram() => (short: prog) = jsload("webgl", "createProgram");
function: glCreateBuffer() => (short: buffer) = jsload("webgl", "createBuffer");
function: glBindBuffer(short: i, short: j) => () = jsload("webgl", "bindBuffer");
function: glBufferData(short: i, *real: offset, short: size, short: j) => () = jsload("webgl", "bufferData");
function: glElementBufferData(short: i, *short: offset, short: size, short: j) => () = jsload("webgl", "elementBufferData");
function: glUseProgram(short: i) => () = jsload("webgl", "useProgram");
function: glGetAttribLocation(short: i, *char: offset, short: size) => (short: loc) = jsload("webgl", "getAttribLocation");
function: glVertexAttribPointer(short: index, short: size, short: type, short: normalized, short: stride, short: offset) => () = jsload("webgl", "vertexAttribPointer");
function: glEnableVertexAttribArray(short: index) => () = jsload("webgl", "enableVertexAttribArray");
function: glDrawArrays(short: i, short: first, short: count) => () = jsload("webgl", "drawArrays");
function: _glGetUniformLocation(short: i, *char: offset, short: size) => (short: loc) = jsload("webgl", "getUniformLocation");
function: glUniformMatrix2fv(short: loc, short: trans, *real: offset) => () = jsload("webgl", "uniformMatrix2fv");
function: glUniformMatrix3fv(short: loc, short: trans, *real: offset) => () = jsload("webgl", "uniformMatrix3fv");
function: glUniformMatrix4fv(short: loc, short: trans, real: offset[16]) => () = jsload("webgl", "uniformMatrix4fv");
function: glUniform1f(short: loc, real: v0) => () = jsload("webgl", "uniform1f");
function: glUniform1fv(short: loc, real: v0) => () = jsload("webgl", "uniform1fv");
function: glUniform1i(short: loc, short: v0) => () = jsload("webgl", "uniform1i");
function: glUniform1iv(short: loc, short: v0) => () = jsload("webgl", "uniform1iv");
function: glUniform2f(short: loc, real: v0, real: v1) => () = jsload("webgl", "uniform2f");
function: glUniform2fv(short: loc, real: v0, real: v1) => () = jsload("webgl", "uniform2fv");
function: glUniform2i(short: loc, short: v0, short: v1) => () = jsload("webgl", "uniform2i");
function: glUniform2iv(short: loc, short: v0, short: v1) => () = jsload("webgl", "uniform2iv");
function: glUniform3f(short: loc, real: v0, real: v1, real: v2) => () = jsload("webgl", "uniform3f");
function: glUniform3fv(short: loc, real: v0, real: v1, real: v2) => () = jsload("webgl", "uniform3fv");
function: glUniform3i(short: loc, short: v0, short: v1, short: v2) => () = jsload("webgl", "uniform3i");
function: glUniform3iv(short: loc, short: v0, short: v1, short: v2) => () = jsload("webgl", "uniform3iv");
function: glUniform4f(short: loc, real: v0, real: v1, real: v2, real: v3) => () = jsload("webgl", "uniform4f");
function: glUniform4fv(short: loc, real: v0, real: v1, real: v2, real: v3) => () = jsload("webgl", "uniform4fv");
function: glUniform4i(short: loc, short: v0, short: v1, short: v2, short: v3) => () = jsload("webgl", "uniform4i");
function: glUniform4iv(short: loc, short: v0, short: v1, short: v2, short: v3) => () = jsload("webgl", "uniform4iv");
function: glClearColor(real: r, real: g, real: b, real: a) => () = jsload("webgl", "clearColor");
function: glClear(short: color) => () = jsload("webgl", "clear");
function: glDrawElements(short: i, short: count, short: type, short: offset) => () = jsload("webgl", "drawElements");
function: glBlendFunc(short: i, short: j) => () = jsload("webgl", "blendFunc");
function: キーチェック(short: keyCode) => (int: pressed) = jsload("js", "checkKeyPress");
function: マウスチェック() => (int: pressed) = jsload("js", "checkMousePress");
function: マウス相対座標X() => (real: x) = jsload("js", "checkRelativeMouseX");
function: マウス相対座標Y() => (real: x) = jsload("js", "checkRelativeMouseY");
function: マウス絶対座標X() => (real: x) = jsload("js", "checkAbsoluteMouseX");
function: マウス絶対座標Y() => (real: x) = jsload("js", "checkAbsoluteMouseY");
function: jsRand() => (real: x) = jsload("js", "rand");
function: メモリ確保(short: size) => (*void: p) = jsload("js", "alloc");
function: _loadTexture(*char: offset, short: length) => (short: a) = jsload("webgl", "loadTexture");
function: glActiveTexture(short: i) => () = jsload("webgl", "activeTexture");
function: glBindTexture(short: i, short: j) => () = jsload("webgl", "bindTexture");
function: クリックしたら消える() => () = jsload("js", "lockPointer");
function: sin(real: input) => (real: 結果){
	real: PI = 3.141593;
	int: temp = input / (2.000000 * PI);
	real: rad = input - (2.000000 * PI * temp);
	real: plusminus = 1.000000;
	if(rad < 0.000000){
		rad = rad + (2.000000 * PI);
	}
	if(rad > PI){
		plusminus = 0 - 1.000000;
		if(rad > 1.500000 * PI){
			rad = (2.000000 * PI) - rad;
		}else{
			rad = rad - PI;
		}
	}else{
		if(rad > 0.500000 * PI){
			rad = PI - rad;
		}
	}
	if(rad > 0.250000 * PI){
		rad = (0.500000 * PI) - rad;
		real: doubleRad = rad * rad;
		結果 = 1.000000 - (doubleRad) / 2.000000 + (doubleRad * doubleRad) / 24.000000 - (doubleRad * doubleRad * doubleRad) / 720.000000 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.000000 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.000000 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.000000;
		結果 = 結果 * plusminus;
	}else{
		real: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.000000 + (rad * doubleRad * doubleRad) / 120.000000 - (rad * doubleRad * doubleRad * doubleRad) / 5040.000000 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.000000 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.000000 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.000000 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.000000;
		結果 = 結果 * plusminus;
	}
}
function: cos(real: input) => (real: 結果){
	real: PI = 3.141593;
	int: temp = input / (2 * PI);
	real: rad = input - (2 * PI * temp);
	real: plusminus = 1.000000;
	if(rad < 0.000000){
		rad = rad + (2.000000 * PI);
	}
	if(rad > PI){
		if(rad > 1.500000 * PI){
			rad = (2.000000 * PI) - rad;
		}else{
			plusminus = 0 - 1.000000;
			rad = rad - PI;
		}
	}else{
		if(rad > 0.500000 * PI){
			plusminus = 0 - 1.000000;
			rad = PI - rad;
		}
	}
	if(rad < 0.250000 * PI){
		real: doubleRad = rad * rad;
		結果 = 1.000000 - (doubleRad) / 2.000000 + (doubleRad * doubleRad) / 24.000000 - (doubleRad * doubleRad * doubleRad) / 720.000000 + (doubleRad * doubleRad * doubleRad * doubleRad) / 40320.000000 - (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 3628800.000000 + (doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 479001600.000000;
		結果 = 結果 * plusminus;
	}else{
		rad = (0.500000 * PI) - rad;
		real: doubleRad = rad * rad;
		結果 = rad - (rad * doubleRad) / 6.000000 + (rad * doubleRad * doubleRad) / 120.000000 - (rad * doubleRad * doubleRad * doubleRad) / 5040.000000 + (rad * doubleRad * doubleRad * doubleRad * doubleRad) / 362880.000000 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 39916800.000000 + (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 6227020800.000000 - (rad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad * doubleRad) / 1307674368000.000000;
		結果 = 結果 * plusminus;
	}
}
function: tan(real: rad) => (real: 結果){
	real: PI = 3.141593;
	real: sqRad = rad * rad;
	結果 = sin(rad) / cos(rad);
}
template<T>: function: abs(T: a) => (T: b){
	if(a >= 0){
		b = a;
	}else{
		b = 0 - a;
	}
}
function: toRad(real: deg) => (real: rad){
	real: PI = 3.141593;
	rad = (deg / 180) * PI;
}
function: root(real: x) => (real: y){
	y = 5;
	(int: i = 0;)from(i == 20)to(i = i + 1;){
		y = 0.500000 * (y + (x / y));
	}
}
function: length3d(real: x, real: y, real: z) => (real: length){
	length = root(x * x + y * y + z * z);
}
function: normalize(real: vector[3]) => (){
	real: length = length3d(vector[0], vector[1], vector[2]);
	if(length == 0.000000){
		return;
	}
	vector[0] = vector[0] / length;
	vector[1] = vector[1] / length;
	vector[2] = vector[2] / length;
}
function: dot(real: vec1[3], real: vec2[3]) => (real: 結果){
	結果 = vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];
}
function: cross(real: output[3], real: vec1[3], real: vec2[3]) => (){
	output[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];
	output[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];
	output[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];
}
function: vecMultiply(real: output[3], real: vec[3], real: x) => (){
	output[0] = vec[0] * x;
	output[1] = vec[1] * x;
	output[2] = vec[2] * x;
}
function: vecSub(real: output[3], real: vec1[3], real: vec2[3]) => (){
	output[0] = vec1[0] - vec2[0];
	output[1] = vec1[1] - vec2[1];
	output[2] = vec1[2] - vec2[2];
}
function: vecAdd(real: output[3], real: vec1[3], real: vec2[3]) => (){
	output[0] = vec1[0] + vec2[0];
	output[1] = vec1[1] + vec2[1];
	output[2] = vec1[2] + vec2[2];
}
template<T>: class: 配列{
public: 	*T: content;
	int: size;
	function: 配列() => (){
		size = 0;
		allocated = 2;
		content = メモリ確保(sizeof(*content) * allocated);
	}
	function: 取得(int: index) => (T: result){
		return(content[index]);
	}
	function: 追加(T: new) => (){
		if(size == allocated){
			allocated = allocated * 2;
			*T: temp = content;
			content = メモリ確保(sizeof(*content) * allocated);
			(int: i = 0;)from(i == allocated)to(i = i + 1;){
				content[i] = temp[i];
			}
		}
		content[size] = new;
		size = size + 1;
	}
	function: 長さ() => (int: a){
		a = size;
	}
	function: ポップ() => (){
		size = size - 1;
	}
private: 	int: allocated;
}
class: 文字列{
public: 	function: =(*char: offset, int: l) => (){
		content = offset;
		length = l;
	}
	function: 代入(*char: offset, int: l) => (){
		content = offset;
		length = l;
	}
	function: 文字列(*char: offset, int: l) => (){
		content = offset;
		length = l;
	}
	int: length;
	*char: content;
}
function: 文字列表示(文字列: a) => (){
	_文字列表示(a.content, a.length);
}
function: 表示(real: x) => (){
	実数表示(x);
}
function: 表示(int: n) => (){
	実数表示(n);
}
function: 表示(文字列: a) => (){
	文字列表示(a);
}
function: glGetUniformLocation(short: i, 文字列: a) => (short: loc){
	loc = _glGetUniformLocation(i, a.content, a.length);
}
class: ベクトル3D{
public: 	function: +(ベクトル3D: a) => (ベクトル3D: b){
		b.x = a.x + x;
		b.y = a.y + y;
		b.z = a.z + z;
	}
	function: 正規化() => (){
		real: l = root((x * x) + (y * y) + (z * z));
		x = x / l;
		y = y / l;
		z = z / l;
	}
	function: 長さ() => (real: l){
		l = root(x * x + y * y + z * z);
	}
	function: ベクトル3D(real: a, real: b, real: c) => (){
		x = a;
		y = b;
		z = c;
	}
	real: z;
	real: y;
	real: x;
}
function: ベクトル3Dの和(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;
}
function: ベクトル3Dの差(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
	result.z = a.z - b.z;
}
function: ベクトル3Dの内積(ベクトル3D: a, ベクトル3D: b) => (real: x){
	x = (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}
function: ベクトル3Dの外積(ベクトル3D: a, ベクトル3D: b) => (ベクトル3D: result){
	result.x = (a.y * b.z) - (a.z * b.y);
	result.y = (a.z * b.x) - (a.x * b.z);
	result.z = (a.x * b.y) - (a.y * b.x);
}
function: ベクトル3D拡大(ベクトル3D: a, real: x) => (ベクトル3D: result){
	result.x = a.x * x;
	result.y = a.y * x;
	result.z = a.z * x;
}
function: ベクトル3D縮小(ベクトル3D: a, real: x) => (ベクトル3D: result){
	if(x == 0.000000){
		表示(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
	result.z = a.z / x;
}
class: 行列4x4{
public: 	function: 拡大縮小(real: x, real: y, real: z) => (){
		matrix[0] = matrix[0] * x;
		matrix[1] = matrix[1] * x;
		matrix[2] = matrix[2] * x;
		matrix[3] = matrix[3] * x;
		matrix[4] = matrix[4] * y;
		matrix[5] = matrix[5] * y;
		matrix[6] = matrix[6] * y;
		matrix[7] = matrix[7] * y;
		matrix[8] = matrix[8] * z;
		matrix[9] = matrix[9] * z;
		matrix[10] = matrix[10] * z;
		matrix[11] = matrix[11] * z;
	}
	function: 回転(ベクトル3D: axis, real: theta) => (){
		axis.正規化();
		real: s = sin(theta);
		real: c = cos(theta);
		real: t = 1.000000 - c;
		real: a00 = matrix[0];
		real: a01 = matrix[1];
		real: a02 = matrix[2];
		real: a03 = matrix[3];
		real: a10 = matrix[4];
		real: a11 = matrix[5];
		real: a12 = matrix[6];
		real: a13 = matrix[7];
		real: a20 = matrix[8];
		real: a21 = matrix[9];
		real: a22 = matrix[10];
		real: a23 = matrix[11];
		real: b00 = axis.x * axis.x * t + c;
		real: b01 = axis.y * axis.x * t + axis.z * s;
		real: b02 = axis.z * axis.x * t - axis.y * s;
		real: b10 = axis.x * axis.y * t - axis.z * s;
		real: b11 = axis.y * axis.y * t + c;
		real: b12 = axis.z * axis.y * t + axis.x * s;
		real: b20 = axis.x * axis.z * t + axis.y * s;
		real: b21 = axis.y * axis.z * t - axis.x * s;
		real: b22 = axis.z * axis.z * t + c;
		matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
		matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
		matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
		matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
		matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
		matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
		matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
		matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
		matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
		matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
		matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
		matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
	}
	function: 移動(ベクトル3D: offset) => (){
		real: mat12 = matrix[12];
		real: mat13 = matrix[13];
		real: mat14 = matrix[14];
		real: mat15 = matrix[15];
		matrix[12] = matrix[0] * offset.x + matrix[4] * offset.y + matrix[8] * offset.z + mat12;
		matrix[13] = matrix[1] * offset.x + matrix[5] * offset.y + matrix[9] * offset.z + mat13;
		matrix[14] = matrix[2] * offset.x + matrix[6] * offset.y + matrix[10] * offset.z + mat13;
		matrix[15] = matrix[3] * offset.x + matrix[7] * offset.y + matrix[11] * offset.z + mat15;
	}
	function: 初期化() => (){
		matrix = [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000];
	}
	function: 行列4x4() => (){
		matrix = [1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000];
	}
	real: matrix[16];
}
function: カメラ行列(行列4x4: m, ベクトル3D: pos, ベクトル3D: lookAt, ベクトル3D: up) => (行列4x4: res){
	ベクトル3D: newForward(lookAt.x - pos.x, lookAt.y - pos.y, lookAt.z - pos.z);
	ベクトル3D: a(0.000000, 0.000000, 0.000000);
	a = ベクトル3D拡大(newForward, ベクトル3Dの内積(up, newForward));
	ベクトル3D: newUp(up.x - a.x, up.y - a.y, up.z - a.z);
	newUp.正規化();
	ベクトル3D: newRight(0, 0, 0);
	newRight = ベクトル3Dの外積(newUp, newForward);
	m.matrix = [newRight.x, newUp.x, newForward.x, 0.000000, newRight.y, newUp.y, newForward.y, 0.000000, newRight.z, newUp.z, newForward.z, 0.000000, 0 - ベクトル3Dの内積(newRight, pos), 0 - ベクトル3Dの内積(newUp, pos), 0 - ベクトル3Dの内積(newForward, pos), 1.000000];
	return(m);
}
function: 視点行列3D(行列4x4: m, real: fov, real: width, real: height, real: zN, real: zF) => (行列4x4: result){
	real: PI = 3.141593;
	real: fov = 1.000000 / tan((90.000000 / 360.000000) * PI);
	real: aspectRatio = width / height;
	real: zNear = zN;
	real: zFar = zF;
	real: zQ = zF / (zF - zN);
	m.matrix = [aspectRatio * fov, 0.000000, 0.000000, 0.000000, 0.000000, fov, 0.000000, 0.000000, 0.000000, 0.000000, zQ, 1.000000, 0.000000, 0.000000, (0 - zFar * zNear) / (zFar - zNear), 0.000000];
	return(m);
}
function: 視点行列2D(行列4x4: m, real: left, real: right, real: bottom, real: top, real: near, real: far) => (行列4x4: result){
	m.matrix = [2.000000 / (right - left), 0.000000, 0.000000, 0.000000, 0.000000, 2.000000 / (top - bottom), 0.000000, 0.000000, 0.000000, 0.000000, 0 - 2.000000 / (near - far), 0.000000, 0 - (right + left) / (right - left), 0 - (top + bottom) / (top - bottom), 0 - (far + near) / (far - near), 1.000000];
	return(m);
}
function: 行列4x4の積(行列4x4: a, 行列4x4: b) => (行列4x4: out){
	out.matrix[0] = b.matrix[0] * a.matrix[0] + b.matrix[1] * a.matrix[4] + b.matrix[2] * a.matrix[8] + b.matrix[3] * a.matrix[12];
	out.matrix[1] = b.matrix[0] * a.matrix[1] + b.matrix[1] * a.matrix[5] + b.matrix[2] * a.matrix[9] + b.matrix[3] * a.matrix[13];
	out.matrix[2] = b.matrix[0] * a.matrix[2] + b.matrix[1] * a.matrix[6] + b.matrix[2] * a.matrix[10] + b.matrix[3] * a.matrix[14];
	out.matrix[3] = b.matrix[0] * a.matrix[3] + b.matrix[1] * a.matrix[7] + b.matrix[2] * a.matrix[11] + b.matrix[3] * a.matrix[15];
	out.matrix[4] = b.matrix[4] * a.matrix[0] + b.matrix[5] * a.matrix[4] + b.matrix[6] * a.matrix[8] + b.matrix[7] * a.matrix[12];
	out.matrix[5] = b.matrix[4] * a.matrix[1] + b.matrix[5] * a.matrix[5] + b.matrix[6] * a.matrix[9] + b.matrix[7] * a.matrix[13];
	out.matrix[6] = b.matrix[4] * a.matrix[2] + b.matrix[5] * a.matrix[6] + b.matrix[6] * a.matrix[10] + b.matrix[7] * a.matrix[14];
	out.matrix[7] = b.matrix[4] * a.matrix[3] + b.matrix[5] * a.matrix[7] + b.matrix[6] * a.matrix[11] + b.matrix[7] * a.matrix[15];
	out.matrix[8] = b.matrix[8] * a.matrix[0] + b.matrix[9] * a.matrix[4] + b.matrix[10] * a.matrix[8] + b.matrix[11] * a.matrix[12];
	out.matrix[9] = b.matrix[8] * a.matrix[1] + b.matrix[9] * a.matrix[5] + b.matrix[10] * a.matrix[9] + b.matrix[11] * a.matrix[13];
	out.matrix[10] = b.matrix[8] * a.matrix[2] + b.matrix[9] * a.matrix[6] + b.matrix[10] * a.matrix[10] + b.matrix[11] * a.matrix[14];
	out.matrix[11] = b.matrix[8] * a.matrix[3] + b.matrix[9] * a.matrix[7] + b.matrix[10] * a.matrix[11] + b.matrix[11] * a.matrix[15];
	out.matrix[12] = b.matrix[12] * a.matrix[0] + b.matrix[13] * a.matrix[4] + b.matrix[14] * a.matrix[8] + b.matrix[15] * a.matrix[12];
	out.matrix[13] = b.matrix[12] * a.matrix[1] + b.matrix[13] * a.matrix[5] + b.matrix[14] * a.matrix[9] + b.matrix[15] * a.matrix[13];
	out.matrix[14] = b.matrix[12] * a.matrix[2] + b.matrix[13] * a.matrix[6] + b.matrix[14] * a.matrix[10] + b.matrix[15] * a.matrix[14];
	out.matrix[15] = b.matrix[12] * a.matrix[3] + b.matrix[13] * a.matrix[7] + b.matrix[14] * a.matrix[11] + b.matrix[15] * a.matrix[15];
}
class: モデル{
public: 	ベクトル3D: color;
	ベクトル3D: pos;
	function: モデル(*real: data, int: num, ベクトル3D: c, ベクトル3D: p, int: s) => (){
		vertices = data;
		vertexNum = num;
		color = c;
		pos = p;
		shaderID = s;
		modelMat.初期化();
		transMat.初期化();
		scaleMat.初期化();
		rotateMat.初期化();
		char: _lightPosUniform[8] = "lightPos";
		char: _viewPosUniform[8] = "viewPos";
		char: _lightColorUniform[10] = "lightColor";
		char: _objectColorUniform[11] = "objectColor";
		char: _projUniform[8] = "uProjMat";
		char: _viewUniform[8] = "uViewMat";
		char: _modelUniform[9] = "uModelMat";
		文字列: lightPosUniform(&_lightPosUniform, 8);
		文字列: viewPosUniform(&_viewPosUniform, 7);
		文字列: lightColorUniform(&_lightColorUniform, 10);
		文字列: objectColorUniform(&_objectColorUniform, 11);
		文字列: projUniform(&_projUniform, 8);
		文字列: viewUniform(&_viewUniform, 8);
		文字列: modelUniform(&_modelUniform, 9);
		if(shaderID == 0){
			viewPosUniLoc = glGetUniformLocation(0, viewPosUniform);
			lightPosUniLoc = glGetUniformLocation(0, lightPosUniform);
			lightColorUniLoc = glGetUniformLocation(0, lightColorUniform);
			objectColorUniLoc = glGetUniformLocation(0, objectColorUniform);
		}
		projMatUniformLoc = glGetUniformLocation(shaderID, projUniform);
		viewMatUniformLoc = glGetUniformLocation(shaderID, viewUniform);
		modelMatUniformLoc = glGetUniformLocation(shaderID, modelUniform);
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, num * 6, 35044);
	}
	function: 座標設定(ベクトル3D: coord) => (){
		pos = coord;
	}
	function: 移動(ベクトル3D: offset) => (){
		pos = ベクトル3Dの和(pos, offset);
	}
	function: 拡大縮小(real: x, real: y, real: z) => (){
		行列4x4: temp();
		temp.初期化();
		temp.拡大縮小(x, y, z);
		scaleMat = 行列4x4の積(temp, scaleMat);
	}
	function: 回転(ベクトル3D: axis, real: t) => (){
		行列4x4: temp();
		temp.初期化();
		temp.回転(axis, t);
		rotateMat = 行列4x4の積(temp, rotateMat);
	}
	function: 描画(行列4x4: projMat, 行列4x4: viewMat, ベクトル3D: camera) => (){
		real: PI = 3.141593;
		transMat.移動(pos);
		modelMat.初期化();
		modelMat = 行列4x4の積(scaleMat, modelMat);
		modelMat = 行列4x4の積(rotateMat, modelMat);
		modelMat = 行列4x4の積(transMat, modelMat);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 6 * 4, 0);
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, 5126, 0, 6 * 4, 3 * 4);
		glUseProgram(shaderID);
		if(shaderID == 0){
			glUniform3f(lightPosUniLoc, 5.000000, 5.000000, 5.000000);
			glUniform3f(lightColorUniLoc, 1.000000, 1.000000, 1.000000);
			glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
			glUniform3f(viewPosUniLoc, camera.x, camera.y, camera.z);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(viewMatUniformLoc, 0, viewMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		glDrawArrays(4, 0, 36);
		rotateMat.初期化();
		transMat.初期化();
		scaleMat.初期化();
	}
private: 	short: modelMatUniformLoc;
	short: viewMatUniformLoc;
	short: projMatUniformLoc;
	short: objectColorUniLoc;
	short: lightColorUniLoc;
	short: lightPosUniLoc;
	short: viewPosUniLoc;
	int: shaderID;
	行列4x4: rotateMat;
	行列4x4: scaleMat;
	行列4x4: transMat;
	行列4x4: modelMat;
	short: buffer;
	int: vertexNum;
	*real: vertices;
}
class: カメラ{
public: 	ベクトル3D: 座標;
	real: 感度;
	function: カメラ(ベクトル3D: p) => (){
		座標 = p;
		view.ベクトル3D(0.000000, 0.000000, 1.000000);
		lookDir.ベクトル3D(0.000000, 0.000000, 1.000000);
		up.ベクトル3D(0.000000, 1.000000, 0.000000);
		yaw = 90.000000;
		pitch = 0.000000;
		感度 = 0.100000;
	}
	function: 感度設定(real: s) => (){
		感度 = s;
	}
	function: アップデート(real: xOffset, real: yOffset, real: elapsedTime) => (行列4x4: result){
		if(キーチェック(32) == 1){
			座標.y = 座標.y + elapsedTime * 5.000000;
		}
		if(キーチェック(16) == 1){
			座標.y = 座標.y - elapsedTime * 5.000000;
		}
		if(キーチェック(65) == 1){
			座標.z = 座標.z - elapsedTime * sin(toRad(yaw - 90)) * 5.000000;
			座標.x = 座標.x - elapsedTime * cos(toRad(yaw - 90)) * 5.000000;
		}
		if(キーチェック(68) == 1){
			座標.z = 座標.z + elapsedTime * sin(toRad(yaw - 90)) * 5.000000;
			座標.x = 座標.x + elapsedTime * cos(toRad(yaw - 90)) * 5.000000;
		}
		if(キーチェック(87) == 1){
			座標.z = 座標.z + elapsedTime * sin(toRad(yaw)) * 5.000000;
			座標.x = 座標.x + elapsedTime * cos(toRad(yaw)) * 5.000000;
		}
		if(キーチェック(83) == 1){
			座標.z = 座標.z - elapsedTime * sin(toRad(yaw)) * 5.000000;
			座標.x = 座標.x - elapsedTime * cos(toRad(yaw)) * 5.000000;
		}
		yaw = yaw - xOffset * 感度;
		pitch = pitch - yOffset * 感度;
		if(pitch < 0 - 89.000000){
			pitch = 0 - 89.000000;
		}
		if(pitch > 89.000000){
			pitch = 89.000000;
		}
		lookDir.x = cos(toRad(yaw)) * cos(toRad(pitch));
		lookDir.y = sin(toRad(pitch));
		lookDir.z = sin(toRad(yaw)) * cos(toRad(pitch));
		lookDir.正規化();
		result.初期化();
		view = ベクトル3Dの和(lookDir, 座標);
		result = カメラ行列(result, 座標, view, up);
	}
private: 	real: pitch;
	real: yaw;
	ベクトル3D: up;
	ベクトル3D: lookDir;
	ベクトル3D: view;
}
class: シーン{
public: 	配列<*モデル>: スプライト;
	カメラ: 目;
	function: シーン() => (){
		last = 時間計測() / 1000.000000;
		now = 0.000000;
		elapsedTime = 0.000000;
		lastX = マウス絶対座標X();
		lastY = マウス絶対座標Y();
		projMat.初期化();
		viewMat.初期化();
		projMat = 視点行列3D(projMat, 90.000000, 720.000000, 1280.000000, 0.100000, 100.000000);
		ベクトル3D: temp(0.000000, 0.000000, 0 - 4.000000);
		目.カメラ(temp);
		スプライト.配列();
	}
	function: 描画() => (){
		now = 時間計測() / 1000.000000;
		elapsedTime = now - last;
		last = now;
		glClearColor(0.000000, 0.000000, 0.000000, 1.000000);
		glClearDepth(1.000000);
		glEnable(2929);
		glDepthFunc(515);
		glClear(16640);
		real: xOffset = マウス絶対座標X() - lastX;
		real: yOffset = マウス絶対座標Y() - lastY;
		lastX = マウス絶対座標X();
		lastY = マウス絶対座標Y();
		viewMat.初期化();
		viewMat = 目.アップデート(xOffset, yOffset, elapsedTime);
		(int: i = 0;)from(i == スプライト.size)to(i = i + 1;){
			スプライト.取得(i)->描画(projMat, viewMat, 目.座標);
		}
	}
	function: キューブ追加(real: size, ベクトル3D: color, ベクトル3D: pos) => (int: id){
		real: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [0 - size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, size / 2, 1.000000, 0.000000, 0.000000]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, size / 2, 1.000000, 0.000000, 0.000000], [size / 2, 0 - size / 2, size / 2, 1.000000, 0.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000], [size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000]], [[0 - size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000]], [[0 - size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000], [size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000]]];
		*モデル: cube = メモリ確保(sizeof(*cube));
		cube->モデル(&vertices, 36, color, pos, 0);
		スプライト.追加(cube);
		id = スプライト.長さ() - 1;
	}
	function: ライト追加(real: size, ベクトル3D: color, ベクトル3D: pos) => (int: id){
		real: vertices[12][3][6] = [[[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [0 - size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000]], [[0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000], [size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0.000000, 0 - 1.000000]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, size / 2, 1.000000, 0.000000, 0.000000]], [[size / 2, 0 - size / 2, 0 - size / 2, 1.000000, 0.000000, 0.000000], [size / 2, size / 2, size / 2, 1.000000, 0.000000, 0.000000], [size / 2, 0 - size / 2, size / 2, 1.000000, 0.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000], [size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 0.000000, 1.000000], [0 - size / 2, 0 - size / 2, size / 2, 0.000000, 0.000000, 1.000000]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000]], [[0 - size / 2, 0 - size / 2, size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0 - 1.000000, 0.000000, 0.000000]], [[0 - size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000], [0 - size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000]], [[0 - size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, size / 2, 0.000000, 1.000000, 0.000000], [size / 2, size / 2, 0 - size / 2, 0.000000, 1.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000]], [[size / 2, 0 - size / 2, size / 2, 0.000000, 0 - 1.000000, 0.000000], [0 - size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000], [size / 2, 0 - size / 2, 0 - size / 2, 0.000000, 0 - 1.000000, 0.000000]]];
		*モデル: light = メモリ確保(sizeof(*light));
		light->モデル(&vertices, 36, color, pos, 1);
		スプライト.追加(light);
		id = スプライト.長さ() - 1;
	}
private: 	real: lastY;
	real: lastX;
	real: elapsedTime;
	real: now;
	real: last;
	行列4x4: viewMat;
	行列4x4: projMat;
}
class: ベクトル2D{
public: 	function: 正規化() => (){
		real: l = root(x * x + y * y);
		x = x / l;
		y = y / l;
	}
	function: 長さ() => (real: l){
		l = root(x * x + y * y);
	}
	function: ベクトル2D(real: a, real: b) => (){
		x = a;
		y = b;
	}
	real: y;
	real: x;
}
function: ベクトル2Dの和(ベクトル2D: a, ベクトル2D: b) => (ベクトル2D: result){
	result.x = a.x + b.x;
	result.y = a.y + b.y;
}
function: ベクトル2Dの差(ベクトル2D: a, ベクトル2D: b) => (ベクトル2D: result){
	result.x = a.x - b.x;
	result.y = a.y - b.y;
}
function: ベクトル2Dの内積(ベクトル2D: a, ベクトル2D: b) => (real: x){
	x = a.x * b.x + a.y * b.y;
}
function: ベクトル2D拡大(ベクトル2D: a, real: x) => (ベクトル2D: result){
	result.x = a.x * x;
	result.y = a.y * x;
}
function: ベクトル2D縮小(ベクトル2D: a, real: x) => (ベクトル2D: result){
	if(x == 0.000000){
		表示(10000000);
	}
	result.x = a.x / x;
	result.y = a.y / x;
}
class: アニメーション情報{
public: 	function: アニメーション情報(int: a, real: start, real: d, real: x, real: y) => (){
		id = a;
		startTime = start;
		duration = d;
		info.x = x;
		info.y = y;
	}
	ベクトル2D: info;
	real: duration;
	real: startTime;
	int: id;
}
class: スプライト{
public: 	ベクトル3D: color;
	ベクトル2D: pos;
	real: 透明度;
	real: scaleX;
	real: scaleY;
	real: theta;
	function: スプライト(*real: data, int: pnum, *short: indicesData, int: vnum, ベクトル3D: c, ベクトル2D: p, int: s, real: zI) => (){
		vertices = data;
		pointNum = pnum;
		indices = indicesData;
		vertexNum = vnum;
		zIndex = zI;
		透明度 = 1.000000;
		color = c;
		pos = p;
		scaleX = 1.000000;
		scaleY = 1.000000;
		theta = 0.000000;
		shaderID = s;
		animations.配列();
		modelMat.初期化();
		transMat.初期化();
		scaleMat.初期化();
		rotateMat.初期化();
		char: _objectColorUniform[11] = "objectColor";
		char: _projUniform[10] = "projection";
		char: _modelUniform[5] = "model";
		char: _samplerUniform[8] = "uSampler";
		char: _transparencyUniform[12] = "transparency";
		文字列: objectColorUniform(&_objectColorUniform, 11);
		文字列: projUniform(&_projUniform, 10);
		文字列: modelUniform(&_modelUniform, 5);
		文字列: samplerUniform(&_samplerUniform, 8);
		文字列: transparencyUniform(&_transparencyUniform, 12);
		projMatUniformLoc = glGetUniformLocation(shaderID, projUniform);
		modelMatUniformLoc = glGetUniformLocation(shaderID, modelUniform);
		if(shaderID == 4){
			transparencyUniLoc = glGetUniformLocation(shaderID, transparencyUniform);
			objectColorUniLoc = glGetUniformLocation(shaderID, objectColorUniform);
		}
		if(shaderID == 3){
			samplerUniformLoc = glGetUniformLocation(shaderID, samplerUniform);
		}
		buffer = glCreateBuffer();
		glBindBuffer(34962, buffer);
		glBufferData(34962, vertices, pnum * 3, 35044);
		if(vnum > 0){
			elementBuffer = glCreateBuffer();
			glBindBuffer(34963, elementBuffer);
			glElementBufferData(34963, indices, vnum, 35044);
		}
	}
	function: テクスチャ設定(*real: tex, 文字列: url) => (){
		shaderID = 0;
		texCoords = tex;
		texture = _loadTexture(url.content, url.length);
		_文字列表示(url.content, url.length);
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	function: リピートテクスチャ設定(*real: tex, short: テクスチャ) => (){
		shaderID = 0;
		texCoords = tex;
		texture = テクスチャ;
		texCoordBuffer = glCreateBuffer();
		glBindBuffer(34962, texCoordBuffer);
		glBufferData(34962, tex, vertexNum * 2, 35044);
	}
	function: 座標設定(ベクトル2D: coord) => (){
		pos = coord;
	}
	function: 移動(ベクトル2D: offset) => (){
		pos = ベクトル2Dの和(pos, offset);
	}
	function: 拡大縮小(real: x, real: y) => (){
		scaleX = scaleX * x;
		scaleY = scaleY * y;
	}
	function: 回転(real: t) => (){
		theta = theta + t;
	}
	function: 角度設定(real: t) => (){
		theta = t;
	}
	function: zIndex設定(real: x) => (){
		zIndex = x;
	}
	function: 透明度設定(real: x) => (){
		透明度 = x;
	}
	function: 色設定(ベクトル3D: 色) => (){
		color = 色;
	}
	function: 描画(行列4x4: projMat) => (){
		real: PI = 3.141593;
		(int: カウンタ = 0;)from(カウンタ == animations.size)to(カウンタ = カウンタ + 1;){
			アニメーション情報: info = animations.取得(カウンタ);
			if((info.startTime <= 時間計測()) && ((info.startTime + info.duration) >= 時間計測())){
				if(info.id == 0){
					real: elapsedTime = 時間計測() - info.startTime;
					回転(info.info.x * elapsedTime);
				}
				if(info.id == 1){
					拡大縮小(info.info.x, info.info.y);
				}
				if(info.id == 2){
					real: elapsedTime = 時間計測() - info.startTime;
					ベクトル2D: offset(info.info.x * elapsedTime, info.info.y * elapsedTime);
					移動(offset);
				}
			}
		}
		ベクトル3D: pos3d(pos.x, pos.y, 0 - zIndex * 0.001000);
		transMat.初期化();
		transMat.移動(pos3d);
		scaleMat.初期化();
		scaleMat.拡大縮小(scaleX, scaleY, 1.000000);
		ベクトル3D: 回転軸(0.000000, 0.000000, 1.000000);
		rotateMat.初期化();
		rotateMat.回転(回転軸, theta);
		modelMat.初期化();
		modelMat = 行列4x4の積(scaleMat, modelMat);
		modelMat = 行列4x4の積(rotateMat, modelMat);
		modelMat = 行列4x4の積(transMat, modelMat);
		glUseProgram(shaderID);
		glBindBuffer(34962, buffer);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, 5126, 0, 0, 0);
		if(shaderID == 4){
			glUniform1f(transparencyUniLoc, 透明度);
			glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
		}
		if(shaderID == 3){
			glBindBuffer(34962, texCoordBuffer);
			glEnableVertexAttribArray(1);
			glVertexAttribPointer(1, 2, 5126, 0, 0, 0);
			glActiveTexture(texture + 33984);
			glBindTexture(3553, texture);
			glUniform1i(samplerUniformLoc, texture);
		}
		glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
		glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
		if(vertexNum > 0){
			glBindBuffer(34963, elementBuffer);
			glDrawElements(4, vertexNum, 5123, 0);
		}
		if((vertexNum == 0) && (shaderID == 4)){
			glBindBuffer(34962, buffer);
			glDrawArrays(5, 0, pointNum);
		}
		rotateMat.初期化();
		transMat.初期化();
		scaleMat.初期化();
	}
	function: 回転アニメーション(real: theta, real: start, real: duration) => (){
		アニメーション情報: temp(0, start, duration, theta, 0.000000);
		animations.追加(temp);
	}
	function: 拡大縮小アニメーション(real: x, real: y, real: start, real: duration) => (){
		アニメーション情報: temp(1, start, duration, x, y);
		animations.追加(temp);
	}
	function: 移動アニメーション(ベクトル2D: offset, real: start, real: duration) => (){
		アニメーション情報: temp(0, start, duration, offset.x, offset.y);
		animations.追加(temp);
	}
private: 	配列<アニメーション情報>: animations;
	short: samplerUniformLoc;
	short: modelMatUniformLoc;
	short: projMatUniformLoc;
	short: transparencyUniLoc;
	short: objectColorUniLoc;
	int: shaderID;
	real: zIndex;
	行列4x4: rotateMat;
	行列4x4: scaleMat;
	行列4x4: transMat;
	行列4x4: modelMat;
	short: texture;
	short: elementBuffer;
	short: texCoordBuffer;
	short: buffer;
	int: pointNum;
	int: vertexNum;
	*real: texCoords;
	*short: indices;
	*real: vertices;
}
class: シーン2D{
public: 	配列<*スプライト>: スプライト配列;
	ベクトル3D: 背景色;
	real: 背景透明度;
	function: シーン2D(real: 高さ, ベクトル3D: color) => (){
		last = 時間計測() / 1000.000000;
		now = 0.000000;
		elapsedTime = 0.000000;
		projMat.初期化();
		projMat = 視点行列2D(projMat, 0 - 高さ / 2.000000 * 16.000000 / 9.000000, 高さ / 2.000000 * 16.000000 / 9.000000, 0 - 高さ / 2, 高さ / 2, 0 - 5.000000, 5.000000);
		スプライト配列.配列();
		背景色 = color;
		背景透明度 = 1.000000;
	}
	function: 背景透明度設定(real: a) => (){
		背景透明度 = a;
	}
	function: 描画() => (){
		now = 時間計測() / 1000.000000;
		elapsedTime = now - last;
		last = now;
		glClearColor(背景色.x, 背景色.y, 背景色.z, 背景透明度);
		glClearDepth(1.000000);
		glEnable(2929);
		glDepthFunc(515);
		glEnable(3042);
		glBlendFunc(770, 771);
		glClear(16640);
		(int: i = 0;)from(i == スプライト配列.size)to(i = i + 1;){
			スプライト配列.取得(i)->描画(projMat);
		}
	}
	function: 正方形追加(real: size, ベクトル2D: pos, ベクトル3D: color, real: zIndex) => (int: id){
		real: vertices[4][3] = [[size / 2, size / 2, 0 - zIndex * 0.001000], [size / 2, 0 - size / 2, 0 - zIndex * 0.001000], [0 - size / 2, 0 - size / 2, 0 - zIndex * 0.001000], [0 - size / 2, size / 2, 0 - zIndex * 0.001000]];
		real: texCoords[4][2] = [[1.000000, 0.000000], [1.000000, 1.000000], [0.000000, 1.000000], [0.000000, 0.000000]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		*スプライト: sprite = メモリ確保(sizeof(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, color, pos, 4, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	function: スプライト追加(real: width, real: height, ベクトル2D: pos, 文字列: url, real: zIndex) => (int: id){
		real: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.001000], [width / 2, 0 - height / 2, 0 - zIndex * 0.001000], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.001000], [0 - width / 2, height / 2, 0 - zIndex * 0.001000]];
		real: texCoords[4][2] = [[1.000000, 0.000000], [1.000000, 1.000000], [0.000000, 1.000000], [0.000000, 0.000000]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		ベクトル3D: color(0.000000, 0.000000, 0.000000);
		*スプライト: sprite = メモリ確保(sizeof(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, color, pos, 3, zIndex);
		sprite->テクスチャ設定(&texCoords, url);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	function: リピートスプライト追加(real: width, real: height, ベクトル2D: pos, short: texture, real: zIndex) => (int: id){
		real: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.001000], [width / 2, 0 - height / 2, 0 - zIndex * 0.001000], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.001000], [0 - width / 2, height / 2, 0 - zIndex * 0.001000]];
		real: texCoords[4][2] = [[1.000000, 0.000000], [1.000000, 1.000000], [0.000000, 1.000000], [0.000000, 0.000000]];
		short: indices[6] = [0, 1, 3, 1, 2, 3];
		ベクトル3D: color(0.000000, 0.000000, 0.000000);
		*スプライト: sprite = メモリ確保(sizeof(*sprite));
		sprite->スプライト(&vertices, 4, &indices, 6, color, pos, 3, zIndex);
		sprite->リピートテクスチャ設定(&texCoords, texture);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	function: 四角形追加(real: width, real: height, ベクトル2D: pos, ベクトル3D: color, real: zIndex) => (int: id){
		real: vertices[4][3] = [[width / 2, height / 2, 0 - zIndex * 0.001000], [0 - width / 2, height / 2, 0 - zIndex * 0.001000], [width / 2, 0 - height / 2, 0 - zIndex * 0.001000], [0 - width / 2, 0 - height / 2, 0 - zIndex * 0.001000]];
		*スプライト: sprite = メモリ確保(sizeof(*sprite));
		sprite->スプライト(&vertices, 4, メモリ確保(0), 0, color, pos, 4, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	function: 多角形追加(*void: points, int: size, ベクトル2D: pos, ベクトル3D: color, real: zIndex) => (int: id){
		*スプライト: sprite = メモリ確保(sizeof(*sprite));
		sprite->スプライト(points, size, メモリ確保(0), 0, color, pos, 4, zIndex);
		スプライト配列.追加(sprite);
		id = スプライト配列.長さ() - 1;
	}
	function: 円追加(real: r, ベクトル2D: pos, ベクトル3D: color, real: zIndex) => (int: id){
		real: PI = 3.141593;
		配列<ベクトル3D>: points();
		int: 頂点数 = 60;
		(int: i = 0;)from(i == 頂点数)to(i = i + 1;){
			real: theta = 0;
			if((i % 2) == 0){
				theta = 0.500000 * PI + ((PI * i) / 頂点数);
			}
			if((i % 2) == 1){
				theta = 0.500000 * PI - ((PI * (1.000000 + i)) / 頂点数);
			}
			ベクトル3D: temp(r * cos(theta), r * sin(theta), 0 - zIndex * 0.001000);
			points.追加(temp);
		}
		id = 多角形追加(points.content, points.size, pos, color, zIndex);
	}
private: 	real: elapsedTime;
	real: now;
	real: last;
	行列4x4: projMat;
}
function: 引数なしjsリスナー呼び出し(function: () => (): callback) => (){
	callback();
}
jsexport(引数なしjsリスナー呼び出し, "jsCallListenerNoParam");
function: Arduino5V送る(int: ピン番号) => (){
	Arduinoコマンド送信(H, ピン番号);
}
function: Arduino0V送る(int: ピン番号) => (){
	Arduinoコマンド送信(L, ピン番号);
}
function: Arduinoピン入出力設定(int: ピン番号, char: 入出力) => (){
	if(入出力 == 入){
		Arduinoコマンド送信(I, ピン番号);
	}
	if(入出力 == 出){
		Arduinoコマンド送信(O, ピン番号);
	}
}
function: Arduinoアナログ入力ピン設定(int: ピン番号) => (){
	Arduinoコマンド送信(A, ピン番号);
}
function: main() => (){
	実数表示();
}
