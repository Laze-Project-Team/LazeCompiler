関数:表示(実数:x)=>()=js読み込み("console", "log");
関数:行列表示(実数:offset[4][4])=>()=js読み込み("console", "logMatrix");
関数:アドレス表示(*無:x)=>()=js読み込み("console", "log");
関数:_文字列表示(*文字:x, 整数:長さ)=>()=js読み込み("console", "logstring");
関数:時間計測()=>(実数:時間)=js読み込み("performance", "now");
関数:glClearDepth(整数32:i)=>()=js読み込み("webgl", "clearDepth");
関数:glDepthFunc(整数32:i)=>()=js読み込み("webgl", "depthFunc");
関数:glEnable(整数32:i)=>()=js読み込み("webgl", "enable");
関数:glDisable(整数32:i)=>()=js読み込み("webgl", "disable");
関数:glCreateProgram()=>(整数32:prog)=js読み込み("webgl", "createProgram");
関数:glCreateBuffer()=>(整数32:buffer)=js読み込み("webgl", "createBuffer");
関数:glBindBuffer(整数32:i, 整数32:j)=>()=js読み込み("webgl", "bindBuffer");
関数:glBufferData(整数32:i, *実数:offset, 整数32:size, 整数32:j)=>()=js読み込み("webgl", "bufferData");
関数:glElementBufferData(整数32:i, *整数32:offset, 整数32:size, 整数32:j)=>()=js読み込み("webgl", "elementBufferData");
関数:glUseProgram(整数32:i)=>()=js読み込み("webgl", "useProgram");
関数:glGetAttribLocation(整数32:i, *文字:offset, 整数32:size)=>(整数32:loc)=js読み込み("webgl", "getAttribLocation");
関数:glVertexAttribPointer(整数32:index, 整数32:size, 整数32:type, 整数32:normalized, 整数32:stride, 整数32:offset)=>()=js読み込み("webgl", "vertexAttribPointer");
関数:glEnableVertexAttribArray(整数32:index)=>()=js読み込み("webgl", "enableVertexAttribArray");
関数:glDrawArrays(整数32:i, 整数32:first, 整数32:count)=>()=js読み込み("webgl", "drawArrays");
関数:_glGetUniformLocation(整数32:i, *文字:offset, 整数32:size)=>(整数32:loc)=js読み込み("webgl", "getUniformLocation");
関数:glUniformMatrix2fv(整数32:loc, 整数32:trans, *実数:offset)=>()=js読み込み("webgl", "uniformMatrix2fv");
関数:glUniformMatrix3fv(整数32:loc, 整数32:trans, *実数:offset)=>()=js読み込み("webgl", "uniformMatrix3fv");
関数:glUniformMatrix4fv(整数32:loc, 整数32:trans, 実数:offset[16])=>()=js読み込み("webgl", "uniformMatrix4fv");
関数:glUniform1f(整数32:loc, 実数: v0)=>()=js読み込み("webgl", "uniform1f");
関数:glUniform1fv(整数32:loc, 実数: v0)=>()=js読み込み("webgl", "uniform1fv");
関数:glUniform1i(整数32:loc, 整数32: v0)=>()=js読み込み("webgl", "uniform1i"); 
関数:glUniform1iv(整数32:loc, 整数32: v0)=>()=js読み込み("webgl", "uniform1iv");
関数:glUniform2f(整数32:loc, 実数: v0, 実数: v1)=>()=js読み込み("webgl", "uniform2f");
関数:glUniform2fv(整数32:loc, 実数: v0, 実数: v1)=>()=js読み込み("webgl", "uniform2fv");
関数:glUniform2i(整数32:loc, 整数32: v0, 整数32: v1)=>()=js読み込み("webgl", "uniform2i");
関数:glUniform2iv(整数32:loc, 整数32: v0, 整数32: v1)=>()=js読み込み("webgl", "uniform2iv");
関数:glUniform3f(整数32:loc, 実数: v0, 実数: v1, 実数: v2)=>()=js読み込み("webgl", "uniform3f");
関数:glUniform3fv(整数32:loc, 実数: v0, 実数: v1, 実数: v2)=>()=js読み込み("webgl", "uniform3fv");
関数:glUniform3i(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2)=>()=js読み込み("webgl", "uniform3i");
関数:glUniform3iv(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2)=>()=js読み込み("webgl", "uniform3iv");
関数:glUniform4f(整数32:loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3)=>()=js読み込み("webgl", "uniform4f");
関数:glUniform4fv(整数32:loc, 実数: v0, 実数: v1, 実数: v2, 実数: v3)=>()=js読み込み("webgl", "uniform4fv");
関数:glUniform4i(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3)=>()=js読み込み("webgl", "uniform4i");
関数:glUniform4iv(整数32:loc, 整数32: v0, 整数32: v1, 整数32: v2, 整数32: v3)=>()=js読み込み("webgl", "uniform4iv");
関数:glClearColor(実数:r, 実数:g, 実数:b, 実数:a)=>()=js読み込み("webgl", "clearColor");
関数:glClear(整数32:color)=>()=js読み込み("webgl", "clear");
関数:glDrawElements(整数32:i, 整数32:count, 整数32:type, 整数32:offset)=>()=js読み込み("webgl", "drawElements");
関数:glBlendFunc(整数32:i, 整数32:j)=>()=js読み込み("webgl", "blendFunc");
関数:キーチェック(整数32:keyCode)=>(整数:pressed)=js読み込み("js", "checkKeyPress");
関数:マウスチェック()=>(整数:pressed)=js読み込み("js", "checkMousePress");
関数:マウス相対座標X()=>(実数:x)=js読み込み("js", "checkRelativeMouseX");
関数:マウス相対座標Y()=>(実数:x)=js読み込み("js", "checkRelativeMouseY");
関数:マウス絶対座標X()=>(実数:x)=js読み込み("js", "checkAbsoluteMouseX");
関数:マウス絶対座標Y()=>(実数:x)=js読み込み("js", "checkAbsoluteMouseY");
関数:jsRand()=>(実数:x)=js読み込み("js", "rand");
関数:メモリ確保(整数32:size)=>(*無:p)=js読み込み("js", "alloc");
関数:_loadTexture(*文字:offset, 整数32:length)=>(整数32:a)=js読み込み("webgl", "loadTexture");
関数:glActiveTexture(整数32:i)=>()=js読み込み("webgl", "activeTexture");
関数:glBindTexture(整数32:i, 整数32:j)=>()=js読み込み("webgl", "bindTexture");
関数:クリックしたら消える() => () = js読み込み("js", "lockPointer"); 
関数:sin(実数:input)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 整数:temp=input/(2.0*PI);
 実数:rad=input-(2.0*PI*temp);
 もし(rad>PI)ならば
 {
  rad=rad-2*PI;
 }
 実数:doubleRad=rad*rad; 
 結果=rad-(rad*doubleRad)/6.0+(rad*doubleRad*doubleRad)/120.0-(rad*doubleRad*doubleRad*doubleRad)/5040.0
  +(rad*doubleRad*doubleRad*doubleRad*doubleRad)/362880.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/39916800.0
  +(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/6227020800.0-(rad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/1307674368000.0;
}

関数:cos(実数:input)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 整数:temp=input/(2*PI);
 実数:rad=input-(2*PI*temp);
 もし(rad>PI)ならば
 {
  rad=rad-2*PI;
 }
 実数:doubleRad=rad*rad;
 結果=1.0-(doubleRad)/2+(doubleRad*doubleRad)/24-(doubleRad*doubleRad*doubleRad)/720+(doubleRad*doubleRad*doubleRad*doubleRad)/40320
  -(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/3628800+(doubleRad*doubleRad*doubleRad*doubleRad*doubleRad*doubleRad)/479001600;
}

関数:tan(実数:rad)=>(実数:結果)
{
 実数:PI=3.14159265358979323846264338;
 実数:sqRad=rad*rad;
    結果=sin(rad)/cos(rad);
}

型<T>:関数:abs(T:a) => (T:b)
{
 もし(a >= 0)ならば{
  b = a;
 }
 でなければ{
  b = -a;
 }
}

関数:toRad(実数:deg)=>(実数:rad)
{
 実数:PI=3.14159265358979323846264338;
 rad = deg/180 * PI;
}

関数:root(実数:x)=>(実数:y)
{
 y=5;
 (整数:i=0;)から(i==20)まで(i++;)
 {
  y=0.5*(y+(x/y));
 }
}

関数:length3d(実数:x, 実数:y, 実数:z)=>(実数:length)
{
 length = root(x*x+y*y+z*z);
}

関数:normalize(実数:vector[3])=>()
{
 実数:length = length3d(vector[0], vector[1], vector[2]);
 もし(length==0.0)ならば
 {
  終了;
 }
 vector[0]=vector[0]/length;
 vector[1]=vector[1]/length;
 vector[2]=vector[2]/length;
}

関数:dot(実数:vec1[3], 実数:vec2[3])=>(実数:結果)
{
 結果=vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2];
}

関数:cross(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[1]*vec2[2]-vec1[2]*vec2[1];
 output[1]=vec1[2]*vec2[0]-vec1[0]*vec2[2];
 output[2]=vec1[0]*vec2[1]-vec1[1]*vec2[0];
}

関数:vecMultiply(実数:output[3], 実数:vec[3], 実数:x)=>()
{
 output[0]=vec[0]*x;
 output[1]=vec[1]*x;
 output[2]=vec[2]*x;
}

関数:vecSub(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[0]-vec2[0];
 output[1]=vec1[1]-vec2[1];
 output[2]=vec1[2]-vec2[2];
}

関数:vecAdd(実数:output[3], 実数:vec1[3], 実数:vec2[3])=>()
{
 output[0]=vec1[0]+vec2[0];
 output[1]=vec1[1]+vec2[1];
 output[2]=vec1[2]+vec2[2];
}
型<T>:クラス:配列
{
    *T:content;
    整数:size;
    関数:配列()=>()
    {
        size = 0;
        allocated = 2;
        //表示(バイト数(*content)); 
        content=メモリ確保(バイト数(*content) * allocated);
    }
    関数:取得(整数:index)=>(T:result)
    {
        終了(content[index]);
    }
    関数:追加(T:new)=>()
    {
        もし(size == allocated)ならば
        {
            allocated = allocated * 2;
            *T:temp = content;
            content = メモリ確保(バイト数( *content)*allocated);
            (整数:i=0;)から(i==allocated)まで(i++;)
            {
                content[i]=temp[i];
            }
        }
        content[size]=new;
        size++;
    }
    関数:長さ()=>(整数:a)
    {
        a = size;
    }
    関数:ポップ() => (){
        size--;
    }
    非公開:
        整数:allocated;
}
 
クラス:文字列
{
    *文字:content;
    整数:length;
    関数:文字列(*文字:offset, 整数:l)=>()
    {
        content = offset;
        length = l;
    }
    関数:代入(*文字:offset, 整数:l)=>()
    {
        content = offset;
        length = l;
    }
}
関数:文字列表示(文字列:a)=>()
{
    _文字列表示(a.content, a.length);
}
関数:glGetUniformLocation(整数32:i, 文字列:a)=>(整数32:loc)
{
    loc = _glGetUniformLocation(i, a.content, a.length);
} 
クラス:ベクトル3D
{
    実数:x;
    実数:y;
    実数:z;
    関数:ベクトル3D(実数:a, 実数:b, 実数:c)=>()
    {
        x = a;
        y = b;
        z = c;
    }
    関数:長さ()=>(実数:l)
    {
        l = root(x*x+y*y+z*z);
    }
    関数:正規化()=>()
    {
        実数:l=root(x*x+y*y+z*z);
        x = x / l;
        y = y / l;
        z = z / l;
    }
}
関数:ベクトル3Dの和(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x = a.x + b.x;
    result.y = a.y + b.y;
    result.z = a.z + b.z;
}
関数:ベクトル3Dの差(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x = a.x - b.x;
    result.y = a.y - b.y;
    result.z = a.z - b.z;
}

関数:ベクトル3Dの内積(ベクトル3D:a, ベクトル3D:b)=>(実数:x)
{
    x = a.x * b.x + a.y * b.y + a.z * b.z;
}

関数:ベクトル3Dの外積(ベクトル3D:a, ベクトル3D:b)=>(ベクトル3D:result)
{
    result.x= a.y * b.z - a.z * b.y;
 result.y= a.z * b.x - a.x * b.z;
 result.z= a.x * b.y - a.y * b.x;
}

関数:ベクトル3D拡大(ベクトル3D:a, 実数:x)=>(ベクトル3D:result)
{
    result.x = a.x * x;
    result.y = a.y * x;
    result.z = a.z * x;
}

関数:ベクトル3D縮小(ベクトル3D:a, 実数:x)=>(ベクトル3D:result)
{
    もし(x == 0.0)ならば{
        表示(10000000);
    }
    result.x = a.x / x;
    result.y = a.y / x;
    result.z = a.z / x;
}
クラス:行列4x4
{
    実数:matrix[16];
    関数:行列4x4()=>()
    {
        matrix = 
        [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ];
    }
    関数:初期化()=>()
    {
        matrix = 
        [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ];
    }
    関数:移動(ベクトル3D:offset)=>()
    {
        実数:mat12=matrix[12];
        実数:mat13=matrix[13];
        実数:mat14=matrix[14];
        実数:mat15=matrix[15];
        matrix[12] = matrix[0] * offset.x + matrix[4] * offset.y + matrix[8] * offset.z + mat12;
        matrix[13] = matrix[1] * offset.x + matrix[5] * offset.y + matrix[9] * offset.z + mat13;
        matrix[14] = matrix[2] * offset.x + matrix[6] * offset.y + matrix[10] * offset.z + mat13;
        matrix[15] = matrix[3] * offset.x + matrix[7] * offset.y + matrix[11] * offset.z + mat15;
    }
    関数:回転(ベクトル3D:axis, 実数:theta)=>()
    {
        axis.正規化();
        実数:s=sin(theta);
        実数:c=cos(theta);
        実数:t=1.0-c;

        実数:a00=matrix[0];
        実数:a01=matrix[1];
        実数:a02=matrix[2];
        実数:a03=matrix[3];
        実数:a10=matrix[4];
        実数:a11=matrix[5];
        実数:a12=matrix[6];
        実数:a13=matrix[7];
        実数:a20=matrix[8];
        実数:a21=matrix[9];
        実数:a22=matrix[10];
        実数:a23=matrix[11];

        実数:b00=axis.x * axis.x * t + c;
        実数:b01=axis.y * axis.x * t + axis.z * s;
        実数:b02=axis.z * axis.x * t - axis.y * s;
        実数:b10=axis.x * axis.y * t - axis.z * s;
        実数:b11=axis.y * axis.y * t + c;
        実数:b12=axis.z * axis.y * t + axis.x * s;
        実数:b20=axis.x * axis.z * t + axis.y * s;
        実数:b21=axis.y * axis.z * t - axis.x * s;
        実数:b22=axis.z * axis.z * t + c;

        matrix[0]=a00 * b00 + a10 * b01 + a20 * b02;
        matrix[1]=a01 * b00 + a11 * b01 + a21 * b02;
        matrix[2]=a02 * b00 + a12 * b01 + a22 * b02;
        matrix[3]=a03 * b00 + a13 * b01 + a23 * b02;
        matrix[4]=a00 * b10 + a10 * b11 + a20 * b12;
        matrix[5]=a01 * b10 + a11 * b11 + a21 * b12;
        matrix[6]=a02 * b10 + a12 * b11 + a22 * b12;
        matrix[7]=a03 * b10 + a13 * b11 + a23 * b12;
        matrix[8]=a00 * b20 + a10 * b21 + a20 * b22;
        matrix[9]=a01 * b20 + a11 * b21 + a21 * b22;
        matrix[10]=a02 * b20 + a12 * b21 + a22 * b22;
        matrix[11]=a03 * b20 + a13 * b21 + a23 * b22;
    }
    関数:拡大縮小(実数:x, 実数:y, 実数:z)=>()
    {
        matrix[0]= matrix[0]*x;
        matrix[1]= matrix[1]*x;
        matrix[2]= matrix[2]*x;
        matrix[3]= matrix[3]*x;
        matrix[4]= matrix[4]*y;
        matrix[5]= matrix[5]*y;
        matrix[6]= matrix[6]*y;
        matrix[7]= matrix[7]*y;
        matrix[8]= matrix[8]*z;
        matrix[9]= matrix[9]*z;
        matrix[10]=matrix[10]*z;
        matrix[11]=matrix[11]*z;
    }
}

関数:カメラ行列(行列4x4:m, ベクトル3D:pos, ベクトル3D:lookAt, ベクトル3D:up)=>(行列4x4:res)
{
    ベクトル3D:newForward(lookAt.x - pos.x, lookAt.y - pos.y, lookAt.z - pos.z);
    ベクトル3D:a(0.0, 0.0, 0.0);
    a = ベクトル3D拡大(newForward, ベクトル3Dの内積(up, newForward));
    //表示(a.x);
    ベクトル3D:newUp(up.x - a.x, up.y - a.y, up.z - a.z);
    newUp.正規化();

    ベクトル3D:newRight(0, 0, 0);
    newRight = ベクトル3Dの外積(newUp, newForward);

    m.matrix = 
    [
        newRight.x, newUp.x, newForward.x, 0.0,
        newRight.y, newUp.y, newForward.y, 0.0,
        newRight.z, newUp.z, newForward.z, 0.0,
        -ベクトル3Dの内積(newRight, pos), -ベクトル3Dの内積(newUp, pos), -ベクトル3Dの内積(newForward, pos), 1.0
    ];
    終了(m);
}

関数:視点行列3D(行列4x4:m, 実数:fov, 実数:width, 実数:height, 実数:zN, 実数:zF)=>(行列4x4:result)
{
 実数:PI=3.141592653589793;
    実数:fov=1.0 / tan((90.0/360.0)*PI);
 実数:aspectRatio=width/height;
 実数:zNear=zN;
 実数:zFar= zF;
 実数:zQ=zF/(zF-zN);
    m.matrix = 
    [
        aspectRatio*fov, 0.0, 0.0, 0.0,
        0.0, fov, 0.0, 0.0,
        0.0, 0.0, zQ, 1.0,
        0.0, 0.0, (-zFar * zNear)/(zFar - zNear), 0.0
    ];
    終了(m);
}

関数:視点行列2D(行列4x4:m, 実数:left, 実数:right, 実数:bottom, 実数:top, 実数:near, 実数:far)=>(行列4x4:result)
{
    m.matrix = 
    [
        2.0/(right - left), 0.0, 0.0, 0.0,
        0.0, 2.0/(top - bottom), 0.0, 0.0,
        0.0, 0.0, -2.0/(near - far), 0.0,
        -(right + left)/(right - left), -(top + bottom)/(top - bottom), -(far + near)/(far - near), 1.0
    ]; 
    終了(m);
}

関数:行列4x4の積(行列4x4:a, 行列4x4:b)=>(行列4x4:out)
{
    out.matrix[0] = b.matrix[0] * a.matrix[0] + b.matrix[1] * a.matrix[4] + b.matrix[2] * a.matrix[8] + b.matrix[3] * a.matrix[12];
    out.matrix[1] = b.matrix[0] * a.matrix[1] + b.matrix[1] * a.matrix[5] + b.matrix[2] * a.matrix[9] + b.matrix[3] * a.matrix[13];
    out.matrix[2] = b.matrix[0] * a.matrix[2] + b.matrix[1] * a.matrix[6] + b.matrix[2] * a.matrix[10] + b.matrix[3] * a.matrix[14];
    out.matrix[3] = b.matrix[0] * a.matrix[3] + b.matrix[1] * a.matrix[7] + b.matrix[2] * a.matrix[11] + b.matrix[3] * a.matrix[15];
    out.matrix[4] = b.matrix[4] * a.matrix[0] + b.matrix[5] * a.matrix[4] + b.matrix[6] * a.matrix[8] + b.matrix[7] * a.matrix[12];
    out.matrix[5] = b.matrix[4] * a.matrix[1] + b.matrix[5] * a.matrix[5] + b.matrix[6] * a.matrix[9] + b.matrix[7] * a.matrix[13];
    out.matrix[6] = b.matrix[4] * a.matrix[2] + b.matrix[5] * a.matrix[6] + b.matrix[6] * a.matrix[10] + b.matrix[7] * a.matrix[14];
    out.matrix[7] = b.matrix[4] * a.matrix[3] + b.matrix[5] * a.matrix[7] + b.matrix[6] * a.matrix[11] + b.matrix[7] * a.matrix[15];
    out.matrix[8] = b.matrix[8] * a.matrix[0] + b.matrix[9] * a.matrix[4] + b.matrix[10] * a.matrix[8] + b.matrix[11] * a.matrix[12];
    out.matrix[9] = b.matrix[8] * a.matrix[1] + b.matrix[9] * a.matrix[5] + b.matrix[10] * a.matrix[9] + b.matrix[11] * a.matrix[13];
    out.matrix[10] = b.matrix[8] * a.matrix[2] + b.matrix[9] * a.matrix[6] + b.matrix[10] * a.matrix[10] + b.matrix[11] * a.matrix[14];
    out.matrix[11] = b.matrix[8] * a.matrix[3] + b.matrix[9] * a.matrix[7] + b.matrix[10] * a.matrix[11] + b.matrix[11] * a.matrix[15];
    out.matrix[12] = b.matrix[12] * a.matrix[0] + b.matrix[13] * a.matrix[4] + b.matrix[14] * a.matrix[8] + b.matrix[15] * a.matrix[12];
    out.matrix[13] = b.matrix[12] * a.matrix[1] + b.matrix[13] * a.matrix[5] + b.matrix[14] * a.matrix[9] + b.matrix[15] * a.matrix[13];
    out.matrix[14] = b.matrix[12] * a.matrix[2] + b.matrix[13] * a.matrix[6] + b.matrix[14] * a.matrix[10] + b.matrix[15] * a.matrix[14];
    out.matrix[15] = b.matrix[12] * a.matrix[3] + b.matrix[13] * a.matrix[7] + b.matrix[14] * a.matrix[11] + b.matrix[15] * a.matrix[15];
}
クラス:モデル
{
    ベクトル3D:color;
    ベクトル3D:pos;

    関数:モデル(*実数:data, 整数:num, ベクトル3D:c, ベクトル3D:p, 整数:s)=>()
    {
        vertices = data;
        vertexNum = num;
        color = c;
        pos = p;
        shaderID = s;

        modelMat.初期化();
        transMat.初期化();
        scaleMat.初期化();
        rotateMat.初期化();

        文字:_lightPosUniform[8]="lightPos";
     文字:_viewPosUniform[8]="viewPos";
     文字:_lightColorUniform[10]="lightColor";
     文字:_objectColorUniform[11]="objectColor";
     文字:_projUniform[8]="uProjMat";
     文字:_viewUniform[8]="uViewMat";
     文字:_modelUniform[9]="uModelMat";

     文字列:lightPosUniform(&_lightPosUniform, 8);
     文字列:viewPosUniform(&_viewPosUniform, 7);
     文字列:lightColorUniform(&_lightColorUniform, 10);
     文字列:objectColorUniform(&_objectColorUniform, 11);
     文字列:projUniform(&_projUniform, 8);
     文字列:viewUniform(&_viewUniform, 8);
     文字列:modelUniform(&_modelUniform, 9);

        もし(shaderID == 0)ならば
        { 
            viewPosUniLoc=glGetUniformLocation(0, viewPosUniform);
         lightPosUniLoc=glGetUniformLocation(0, lightPosUniform);
         lightColorUniLoc=glGetUniformLocation(0, lightColorUniform);
         objectColorUniLoc=glGetUniformLocation(0, objectColorUniform);
        }

        projMatUniformLoc=glGetUniformLocation(shaderID, projUniform);
     viewMatUniformLoc=glGetUniformLocation(shaderID, viewUniform);
     modelMatUniformLoc=glGetUniformLocation(shaderID, modelUniform);
        //アドレス表示(data);   
        buffer = glCreateBuffer();
        glBindBuffer(0x8892, buffer);
        glBufferData(0x8892, vertices, num * 6, 0x88E4);
    }
    関数:座標設定(ベクトル3D:coord)=>()
    {
        pos = coord;
    }
    関数:移動(ベクトル3D:offset)=>()
    {
        pos = ベクトル3Dの和(pos, offset);
    }
    関数:拡大縮小(実数:x, 実数:y, 実数:z)=>()
    {
        行列4x4:temp();
        temp.初期化();
        temp.拡大縮小(x, y, z);
        scaleMat = 行列4x4の積(temp, scaleMat);
    }
    関数:回転(ベクトル3D:axis, 実数:t)=>()
    {
        行列4x4:temp(); 
        temp.初期化(); 
        temp.回転(axis, t);
        rotateMat = 行列4x4の積(temp, rotateMat);
    }
    関数:描画(行列4x4:projMat, 行列4x4:viewMat, ベクトル3D:camera)=>()
    {
     実数:PI=3.14159265358979323846264338;
        transMat.移動(pos);
        modelMat.初期化();
        modelMat = 行列4x4の積(scaleMat, modelMat);
        modelMat = 行列4x4の積(rotateMat, modelMat);
        modelMat = 行列4x4の積(transMat, modelMat);
        glBindBuffer(0x8892, buffer); 
        glEnableVertexAttribArray(0);   
  glVertexAttribPointer(0, 3, 0x1406, 0, 6 * 4, 0);
  glEnableVertexAttribArray(1); 
  glVertexAttribPointer(1, 3, 0x1406, 0, 6 * 4, 3 * 4);
        glUseProgram(shaderID);
        もし(shaderID == 0)ならば{
      glUniform3f(lightPosUniLoc, 5.0, 5.0, 5.0);
      glUniform3f(lightColorUniLoc, 1.0, 1.0, 1.0);
      glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
      glUniform3f(viewPosUniLoc, camera.x, camera.y, camera.z);
        }
  glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
  glUniformMatrix4fv(viewMatUniformLoc, 0, viewMat.matrix);
  glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix);
        glDrawArrays(0x0004, 0, 36);
        rotateMat.初期化();
        transMat.初期化();
        scaleMat.初期化();
    } 

    非公開: 
        *実数:vertices;
        整数:vertexNum; 
        整数32:buffer; 
        行列4x4:modelMat;
        行列4x4:transMat;
        行列4x4:scaleMat;
        行列4x4:rotateMat;
        整数:shaderID;
        整数32:viewPosUniLoc;
        整数32:lightPosUniLoc;
        整数32:lightColorUniLoc;
        整数32:objectColorUniLoc;
        整数32:projMatUniformLoc;
        整数32:viewMatUniformLoc;
        整数32:modelMatUniformLoc; 
} 
クラス:カメラ
{
    ベクトル3D:座標;
    実数:感度;
    関数:カメラ(ベクトル3D:p)=>()
    {
        座標 = p;
        view.ベクトル3D(0.0, 0.0, 1.0);
        lookDir.ベクトル3D(0.0, 0.0, 1.0);
        up.ベクトル3D(0.0, 1.0, 0.0);
        yaw = 90.0;
        pitch = 0.0;
        感度 = 0.1;
    }
    関数:感度設定(実数:s)=>()
    {
        感度 = s;
    }
    関数:アップデート(実数:xOffset, 実数:yOffset, 実数:elapsedTime)=>(行列4x4:result)
    {
        もし(キーチェック(32) == 1)ならば{
   座標.y+=elapsedTime*5.0;
  }
  もし(キーチェック(16) == 1)ならば{
   座標.y-=elapsedTime*5.0;
  }
  もし(キーチェック(65)==1)ならば{
   座標.z-=elapsedTime * sin(toRad(yaw-90))*5.0;
   座標.x-=elapsedTime * cos(toRad(yaw-90))*5.0;
  }
  もし(キーチェック(68)==1)ならば{
   座標.z+=elapsedTime * sin(toRad(yaw-90))*5.0;
   座標.x+=elapsedTime * cos(toRad(yaw-90))*5.0;
  }
  もし(キーチェック(87)==1)ならば{
   座標.z+=elapsedTime * sin(toRad(yaw))*5.0;
   座標.x+=elapsedTime * cos(toRad(yaw))*5.0;
  }
  もし(キーチェック(83)==1)ならば{
   座標.z-=elapsedTime * sin(toRad(yaw))*5.0;
   座標.x-=elapsedTime * cos(toRad(yaw))*5.0;
  }

        yaw -= xOffset * 感度;
        pitch -= yOffset * 感度;
        もし(pitch < -89.0)ならば
        {
            pitch = -89.0;
        }
        もし(pitch > 89.0)ならば
        {
            pitch = 89.0;
        }
        lookDir.x=cos(toRad(yaw))*cos(toRad(pitch));
  lookDir.y=sin(toRad(pitch));
  lookDir.z=sin(toRad(yaw))*cos(toRad(pitch));
  lookDir.正規化();

        result.初期化();
        view = ベクトル3Dの和(lookDir, 座標);
        result = カメラ行列(result, 座標, view, up);
    }
    非公開:
        ベクトル3D:view;
        ベクトル3D:lookDir;
        ベクトル3D:up;
        実数:yaw;
        実数:pitch;
}
クラス:シーン
{
    配列<*モデル>:スプライト;
    カメラ:目;
    関数:シーン()=>()
    {
        last = 時間計測()/1000.0;
        now = 0.0;
        elapsedTime = 0.0;
        lastX = マウス絶対座標X();
        lastY = マウス絶対座標Y();
        projMat.初期化();
        viewMat.初期化();
        projMat = 視点行列3D(projMat, 90.0, 512.0, 512.0, 0.1, 100.0);
        ベクトル3D:temp(0.0, 0.0, -4.0);
        目.カメラ(temp);
        スプライト.配列();
    }
    関数:描画()=>()
    {
        now = 時間計測()/1000.0;
        elapsedTime = now - last;
        last = now;
        glClearColor(0.0, 0.0, 0.0, 1.0);
  glClearDepth(1.0);
  glEnable(0x0B71);
  glDepthFunc(0x0203);
  glClear(16640);

        実数:xOffset=マウス絶対座標X()-lastX;
  実数:yOffset=マウス絶対座標Y()-lastY;
  lastX=マウス絶対座標X();
  lastY=マウス絶対座標Y();
        viewMat.初期化();
        viewMat = 目.アップデート(xOffset, yOffset, elapsedTime);
        (整数:i = 0;)から(i == スプライト.size)まで(i++;)
        {
            スプライト.取得(i) -> 描画(projMat, viewMat, 目.座標);
        }
    }
    関数:キューブ追加(実数:size, ベクトル3D:color, ベクトル3D:pos)=>(整数:id)
    {
        実数:vertices[12][3][6]=
     [
         //south
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [-size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, -size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         //east
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0]
         ],
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0],
             [size/2, -size/2, size/2, 1.0, 0.0, 0.0]
         ],
         //north
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, -size/2, size/2, 0.0, 0.0, 1.0]
         ],
         //west
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0],
             [-size/2, -size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         //top
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [-size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0]
         ],
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, -size/2, 0.0, 1.0, 0.0]
         ],
         //bottom
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ], 
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0],
             [size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ]
     ];
        *モデル:cube = メモリ確保(バイト数(*cube)); 
        cube -> モデル(&vertices, 36, color, pos, 0);
        スプライト.追加(cube);
        id = スプライト.長さ() - 1;
    }
    関数:ライト追加(実数:size, ベクトル3D:color, ベクトル3D:pos)=>(整数:id)
    {
        実数:vertices[12][3][6]=
     [
         //south
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [-size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         [
             [-size/2, -size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, size/2, -size/2, 0.0, 0.0, -1.0],
             [size/2, -size/2, -size/2, 0.0, 0.0, -1.0]
         ],
         //east
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0]
         ],
         [
             [size/2, -size/2, -size/2, 1.0, 0.0, 0.0],
             [size/2, size/2, size/2, 1.0, 0.0, 0.0],
             [size/2, -size/2, size/2, 1.0, 0.0, 0.0]
         ],
         //north
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0]
         ],
         [
             [size/2, -size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, size/2, size/2, 0.0, 0.0, 1.0],
             [-size/2, -size/2, size/2, 0.0, 0.0, 1.0]
         ],
         //west
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         [
             [-size/2, -size/2, size/2, -1.0, 0.0, 0.0],
             [-size/2, size/2, -size/2, -1.0, 0.0, 0.0],
             [-size/2, -size/2, -size/2, -1.0, 0.0, 0.0]
         ],
         //top
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [-size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0]
         ],
         [
             [-size/2, size/2, -size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, size/2, 0.0, 1.0, 0.0],
             [size/2, size/2, -size/2, 0.0, 1.0, 0.0]
         ],
         //bottom
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ], 
         [
             [size/2, -size/2, size/2, 0.0, -1.0, 0.0],
             [-size/2, -size/2, -size/2, 0.0, -1.0, 0.0],
             [size/2, -size/2, -size/2, 0.0, -1.0, 0.0]
         ]
     ];
        *モデル:light = メモリ確保(バイト数(*light));
        light -> モデル(&vertices, 36, color, pos, 1);
        スプライト.追加(light);
        id = スプライト.長さ() - 1;
    }
    非公開:
        行列4x4:projMat;
        行列4x4:viewMat;
        実数:last;
        実数:now;
        実数:elapsedTime;
        実数:lastX;
        実数:lastY;
}
クラス:ベクトル2D
{
    実数:x;
    実数:y;
    関数:ベクトル2D(実数:a, 実数:b)=>()
    {
        x = a;
        y = b;
    }
    関数:長さ()=>(実数:l)
    {
        l = root(x*x+y*y);
    }
    関数:正規化()=>()
    {
        実数:l=root(x*x+y*y);
        x = x / l;
        y = y / l;
    }
}
関数:ベクトル2Dの和(ベクトル2D:a, ベクトル2D:b)=>(ベクトル2D:result)
{
    result.x = a.x + b.x;
    result.y = a.y + b.y;
}
関数:ベクトル2Dの差(ベクトル2D:a, ベクトル2D:b)=>(ベクトル2D:result)
{
    result.x = a.x - b.x;
    result.y = a.y - b.y;
}

関数:ベクトル2Dの内積(ベクトル2D:a, ベクトル2D:b)=>(実数:x)
{
    x = a.x * b.x + a.y * b.y;
}

関数:ベクトル2D拡大(ベクトル2D:a, 実数:x)=>(ベクトル2D:result)
{
    result.x = a.x * x;
    result.y = a.y * x;
}

関数:ベクトル2D縮小(ベクトル2D:a, 実数:x)=>(ベクトル2D:result)
{
    もし(x == 0.0)ならば{
        表示(10000000);
    }
    result.x = a.x / x;
    result.y = a.y / x;
}
クラス:アニメーション情報
{
    整数:id;
    実数:startTime;
    実数:duration;
    ベクトル2D:info;
    関数:アニメーション情報(整数:a, 実数:start, 実数:d, 実数:x, 実数:y) => ()
    {
        id = a;
        startTime = start;
        duration = d;
        info.x = x;
        info.y = y;
    }
}

クラス:スプライト
{
    ベクトル3D:color;
    ベクトル2D:pos;
    実数:透明度;
    実数:scaleX;
    実数:scaleY;
    実数:theta;

    関数:スプライト(*実数:data, 整数:pnum, *整数32:indicesData, 整数:vnum, ベクトル3D:c, ベクトル2D:p, 整数:s, 実数:zI)=>()
    { 
        vertices = data;
        pointNum = pnum;
        indices = indicesData;
        vertexNum = vnum;
        zIndex = zI;
        透明度 = 1.0;

        color = c;
        pos = p; 
        scaleX = 1.0;
        scaleY = 1.0;
        theta = 0.0;
        shaderID = s; 

        animations.配列();

        modelMat.初期化();
        transMat.初期化();
        scaleMat.初期化(); 
        rotateMat.初期化();

     文字:_objectColorUniform[11]="objectColor";
     文字:_projUniform[10]="projection"; 
     文字:_modelUniform[5]="model";
     文字:_samplerUniform[8] = "uSampler";
        文字:_transparencyUniform[12]="transparency";

     文字列:objectColorUniform(&_objectColorUniform, 11); 
     文字列:projUniform(&_projUniform, 10);
     文字列:modelUniform(&_modelUniform, 5);
        文字列:samplerUniform(&_samplerUniform, 8);
        文字列:transparencyUniform(&_transparencyUniform, 12);
 
        projMatUniformLoc=glGetUniformLocation(shaderID, projUniform);
     modelMatUniformLoc=glGetUniformLocation(shaderID, modelUniform);
        もし(shaderID == 4)ならば{
            transparencyUniLoc = glGetUniformLocation(shaderID, transparencyUniform);
            objectColorUniLoc = glGetUniformLocation(shaderID, objectColorUniform);
        }
        もし(shaderID == 3)ならば{
            samplerUniformLoc = glGetUniformLocation(shaderID, samplerUniform);
        }

        //アドレス表示(data);   
        buffer = glCreateBuffer();
        glBindBuffer(0x8892, buffer);
        glBufferData(0x8892, vertices, pnum * 3, 0x88E4); 
        もし(vnum > 0)ならば{
            elementBuffer = glCreateBuffer();
            glBindBuffer(0x8893, elementBuffer);
            glElementBufferData(0x8893, indices, vnum, 0x88E4); 
        }
    }
    関数:テクスチャ設定(*実数:tex, 文字列:url)=>()
    {
        shaderID = 0;
        texCoords = tex; 
        texture = _loadTexture(url.content, url.length); 
        _文字列表示(url.content, url.length);

        texCoordBuffer = glCreateBuffer();
        glBindBuffer(0x8892, texCoordBuffer);
        glBufferData(0x8892, tex, vertexNum * 2, 0x88E4);
    }
    関数:リピートテクスチャ設定(*実数:tex, 整数32:テクスチャ)=>()
    {
        shaderID = 0;
        texCoords = tex; 
        texture = テクスチャ; 

        texCoordBuffer = glCreateBuffer();
        glBindBuffer(0x8892, texCoordBuffer);
        glBufferData(0x8892, tex, vertexNum * 2, 0x88E4);
    }
    関数:座標設定(ベクトル2D:coord)=>()
    {
        pos = coord;
    }
    関数:移動(ベクトル2D:offset)=>()
    {
        pos = ベクトル2Dの和(pos, offset);
    }
    関数:拡大縮小(実数:x, 実数:y)=>()
    {
        scaleX = scaleX * x; 
        scaleY = scaleY * y; 
    }
    関数:回転(実数:t)=>()
    {
        theta += t;
    }
    関数:角度設定(実数:t) => ()
    {
        theta = t;
    }
    関数:zIndex設定(実数:x) => ()
    { 
        zIndex = x;
    }  
    関数:透明度設定(実数:x) => ()
    {
        透明度 = x;
    }
    関数:色設定(ベクトル3D:色) => ()
    {
        color = 色;
    }
    関数:描画(行列4x4:projMat)=>()
    {
     実数:PI=3.14159265358979323846264338;
        (animations.size)回繰り返す{
            アニメーション情報:info = animations.取得(カウンタ);
            //表示(info.startTime);
            もし((info.startTime <= 時間計測()) && ((info.startTime + info.duration) >= 時間計測()))ならば{
                もし(info.id == 0)ならば{ 
                    実数:elapsedTime = 時間計測() - info.startTime;  
                    回転(info.info.x * elapsedTime); 
                } 
                もし(info.id == 1)ならば{
                    拡大縮小(info.info.x, info.info.y);
                }
                もし(info.id == 2)ならば{
                    実数:elapsedTime = 時間計測() - info.startTime;
                    ベクトル2D:offset(info.info.x * elapsedTime, info.info.y * elapsedTime);
                    移動(offset);
                }
            }
        }
        ベクトル3D:pos3d(pos.x, pos.y, -zIndex*0.001);
        transMat.初期化();
        transMat.移動(pos3d);
        scaleMat.初期化();
        scaleMat.拡大縮小(scaleX, scaleY, 1.0);
        ベクトル3D:回転軸(0.0, 0.0, 1.0);
        rotateMat.初期化();
        rotateMat.回転(回転軸, theta);
        modelMat.初期化();
        modelMat = 行列4x4の積(scaleMat, modelMat);
        modelMat = 行列4x4の積(rotateMat, modelMat);
        modelMat = 行列4x4の積(transMat, modelMat);
        glUseProgram(shaderID);
        glBindBuffer(0x8892, buffer);
        glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, 3, 0x1406, 0, 0, 0);
        もし(shaderID == 4)ならば{
            glUniform1f(transparencyUniLoc, 透明度);
      glUniform3f(objectColorUniLoc, color.x, color.y, color.z);
        }
        もし(shaderID == 3)ならば{
            glBindBuffer(0x8892, texCoordBuffer);
            glEnableVertexAttribArray(1);
            glVertexAttribPointer(1, 2, 0x1406, 0, 0, 0);

            glActiveTexture(texture + 0x84C0);
            glBindTexture(0x0DE1, texture);
            glUniform1i(samplerUniformLoc, texture);
        }
  glUniformMatrix4fv(projMatUniformLoc, 0, projMat.matrix);
  glUniformMatrix4fv(modelMatUniformLoc, 0, modelMat.matrix); 
        もし(vertexNum > 0)ならば{
            glBindBuffer(0x8893, elementBuffer);   
            glDrawElements(0x0004, vertexNum, 0x1403, 0); 
        }
        もし(vertexNum == 0 && shaderID == 4)ならば{
            glBindBuffer(0x8892, buffer);
            glDrawArrays(0x0005, 0, pointNum);
        }
        rotateMat.初期化(); 
        transMat.初期化();
        scaleMat.初期化(); 
    } 
    関数:回転アニメーション(実数:theta, 実数:start, 実数:duration)=>()
    {
        アニメーション情報:temp(0, start, duration, theta, 0.0);
        animations.追加(temp);
    }
    関数:拡大縮小アニメーション(実数:x, 実数:y, 実数:start, 実数:duration)=>()
    {
        アニメーション情報:temp(1, start, duration, x, y);
        animations.追加(temp);
    }
    関数:移動アニメーション(ベクトル2D:offset, 実数:start, 実数:duration)=>()
    {
        アニメーション情報:temp(0, start, duration, offset.x, offset.y);
        animations.追加(temp);
    }

    非公開: 
        *実数:vertices;
        *整数32:indices;
        *実数:texCoords;
        整数:vertexNum; 
        整数:pointNum;
        整数32:buffer; 
        整数32:texCoordBuffer;
        整数32:elementBuffer;
        整数32:texture;
        行列4x4:modelMat;
        行列4x4:transMat;
        行列4x4:scaleMat;
        行列4x4:rotateMat;
        実数:zIndex;
        整数:shaderID;
        整数32:objectColorUniLoc;
        整数32:transparencyUniLoc;
        整数32:projMatUniformLoc;
        整数32:modelMatUniformLoc; 
        整数32:samplerUniformLoc;
        配列<アニメーション情報>:animations;
} 
クラス:シーン2D
{
    配列<*スプライト>:スプライト配列;
    ベクトル3D:背景色;
    実数:背景透明度;
    関数:シーン2D(実数:高さ, ベクトル3D:color)=>()
    {
        last = 時間計測()/1000.0;
        now = 0.0;
        elapsedTime = 0.0;
        projMat.初期化();
        projMat = 視点行列2D(projMat, -高さ / 2.0 * 16.0 / 9.0, 高さ / 2.0 * 16.0 /9.0, 0.0, 高さ, -5.0, 5.0);
        スプライト配列.配列();
        背景色 = color;
        背景透明度 = 1.0;
    }
    関数:背景透明度設定(実数:a) => ()
    {
        背景透明度 = a;
    }
    関数:描画()=>()
    {
        now = 時間計測()/1000.0;
        elapsedTime = now - last;
        last = now;  
        glClearColor(背景色.x, 背景色.y, 背景色.z, 背景透明度); 
        glClearDepth(1.0); 
        glEnable(0x0B71);
        glDepthFunc(0x0203); 
        glEnable(0x0BE2);   
        glBlendFunc(0x0302, 0x0303);
        glClear(16640);

        (整数:i = 0;)から(i == スプライト配列.size)まで(i++;)
        {
            スプライト配列.取得(i) -> 描画(projMat);
        }
    }
    関数:正方形追加(実数:size, ベクトル2D:pos, ベクトル3D:color, 実数:zIndex)=>(整数:id)
    {
        実数:vertices[4][3]=[
            [ size/2,  size/2, -zIndex*0.001],
            [ size/2, -size/2, -zIndex*0.001],
            [-size/2, -size/2, -zIndex*0.001],
            [-size/2,  size/2, -zIndex*0.001]
        ];
        実数:texCoords[4][2]=[
            [ 1.0,  0.0],
            [ 1.0,  1.0],
            [ 0.0,  1.0],
            [ 0.0,  0.0]
        ];
        整数32:indices[6] = [
            0, 1, 3,
            1, 2, 3
        ];
        *スプライト:sprite = メモリ確保(バイト数(*sprite));   
        sprite -> スプライト(&vertices, 4, &indices, 6, color, pos, 4, zIndex); 
        スプライト配列.追加(sprite);
        id = スプライト配列.長さ() - 1;
    }
    関数:スプライト追加(実数:width, 実数:height, ベクトル2D:pos, 文字列:url, 実数:zIndex)=>(整数:id)
    {
        実数:vertices[4][3]=[
            [ width/2,  height/2, -zIndex*0.001],
            [ width/2, -height/2, -zIndex*0.001],
            [-width/2, -height/2, -zIndex*0.001],
            [-width/2,  height/2, -zIndex*0.001]
        ];
        実数:texCoords[4][2]=[
            [ 1.0,  0.0],
            [ 1.0,  1.0],
            [ 0.0,  1.0],
            [ 0.0,  0.0]
        ];
        整数32:indices[6] = [
            0, 1, 3,
            1, 2, 3
        ];
        ベクトル3D:color(0.0, 0.0, 0.0);
        *スプライト:sprite = メモリ確保(バイト数(*sprite)); 
        sprite -> スプライト(&vertices, 4, &indices, 6, color, pos, 3, zIndex);
        sprite -> テクスチャ設定(&texCoords, url); 
        スプライト配列.追加(sprite);
        id = スプライト配列.長さ() - 1; 
    } 
    関数:リピートスプライト追加(実数:width, 実数:height, ベクトル2D:pos, 整数32:texture, 実数:zIndex)=>(整数:id)
    {
        実数:vertices[4][3]=[
            [ width/2,  height/2, -zIndex*0.001],
            [ width/2, -height/2, -zIndex*0.001],
            [-width/2, -height/2, -zIndex*0.001],
            [-width/2,  height/2, -zIndex*0.001]
        ];
        実数:texCoords[4][2]=[
            [ 1.0,  0.0],
            [ 1.0,  1.0],
            [ 0.0,  1.0],
            [ 0.0,  0.0]
        ];
        整数32:indices[6] = [
            0, 1, 3,
            1, 2, 3
        ];
        ベクトル3D:color(0.0, 0.0, 0.0);
        *スプライト:sprite = メモリ確保(バイト数(*sprite)); 
        sprite -> スプライト(&vertices, 4, &indices, 6, color, pos, 3, zIndex);
        sprite -> リピートテクスチャ設定(&texCoords, texture); 
        スプライト配列.追加(sprite);
        id = スプライト配列.長さ() - 1; 
    }
    関数:四角形追加(実数:width, 実数:height, ベクトル2D:pos, ベクトル3D:color, 実数:zIndex) => (整数:id)
    {
        実数:vertices[4][3]=[
            [ width/2,  height/2, -zIndex*0.001],
            [-width/2,  height/2, -zIndex*0.001],
            [ width/2, -height/2, -zIndex*0.001],
            [-width/2, -height/2, -zIndex*0.001]
        ];
        *スプライト:sprite = メモリ確保(バイト数(*sprite)); 
        sprite -> スプライト(&vertices, 4, メモリ確保(0), 0, color, pos, 4, zIndex);
        スプライト配列.追加(sprite);
        id = スプライト配列.長さ() - 1;
    }
    関数:多角形追加(*無:points, 整数:size, ベクトル2D:pos, ベクトル3D:color, 実数:zIndex) => (整数:id)
    {
        *スプライト:sprite = メモリ確保(バイト数(*sprite));
        sprite -> スプライト(points, size, メモリ確保(0), 0, color, pos, 4, zIndex);  
        スプライト配列.追加(sprite);
        id = スプライト配列.長さ() - 1;
    }
    関数:円追加(実数:r, ベクトル2D:pos, ベクトル3D:color, 実数:zIndex) => (整数:id)
    {
        実数:PI=3.141592653589793;
        配列<ベクトル3D>:points(); 
        整数:頂点数=60;
        (整数:i = 0;)から(i == 頂点数)まで(i++;){
            実数:theta = 0; 
            もし((i % 2) == 0)ならば{
                theta = 0.5*PI+((PI*i)/頂点数);
            }
            もし((i % 2) == 1)ならば{
                theta = 0.5*PI-((PI*(1.0+i))/頂点数); 
            }
            ベクトル3D:temp(r * cos(theta), r * sin(theta), -zIndex*0.001); 
            points.追加(temp);   
        } 
        id = 多角形追加(points.content, points.size, pos, color, zIndex); 
    } 
    非公開:
        行列4x4:projMat;
        実数:last;
        実数:now;
        実数:elapsedTime;
}
#include "std.laze"

クラス:波
{
    実数:周期;
    実数:波長;
    整数:向き;
    実数:開始時間;
    関数:波(実数:TT, 実数:λ, 整数:direction, 実数:start) => (){
        周期 = TT;
        波長 = λ;
        向き = direction;
        開始時間 = start;
    }
}

クラス:線
{
    配列<*波>:波の配列;
    整数:媒質IDスタート;a
    実数:長さ;
    整数:媒質数;
    実数:間の距離;
    関数:線(整数:N, 実数:l, *シーン:ワールド) => (){
        波の配列.配列();
        長さ = l;
        媒質数 = N;
        間の距離 = l/N;
        媒質IDスタート = ワールド -> スプライト.長さ();
        ベクトル3D:初期座標(0.0, 0.0, 0.0);
        ベクトル3D:青(0.2, 0.5, 1.0);
        (媒質数)回繰り返す{
            整数:temp = ワールド -> キューブ追加(0.15, 初期座標, 青);
        }
    }
    関数:アップデート(*シーン:ワールド)=>(){
        (媒質数)回繰り返す{
            実数:x = 間の距離 * カウンタ;
            ベクトル3D:座標(x, 0.0, 0.0);
            (整数:i = 0;)から(i == 波の配列.長さ())まで(i++;){
                実数:周期 = (波の配列.取得(i) -> 周期);
                実数:λ = (波の配列.取得(i) -> 波長);
                実数:start = (波の配列.取得(i) -> 開始時間);
                実数:位相 = (時間計測() - start)/周期 - x/λ;
                もし(位相 > 0.0)ならば{
                    座標.y += sin(位相);
                }
            }
            ワールド -> スプライト.取得(媒質IDスタート + カウンタ) -> 座標設定(座標);
        }
        ワールド -> 描画();
    }
    関数:波追加(実数:周期, 実数:λ, 整数:向き, 実数:開始時間)=>(){
        *波:wave = メモリ確保(バイト数(wave));
        wave -> 波(周期, λ, 向き, 開始時間);
        波の配列.追加(wave);
    }
}

関数:実行 () => () {
    シーン:ワールド(); 
    線:line(300, 20.0, &ワールド); 
    line.波追加(300.0, 1.0, 1, 時間計測());
    無限ループ{                      
        line.アップデート(&ワールド);
    }
}